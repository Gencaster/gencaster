import gql from "graphql-tag";
import * as Urql from "@urql/vue";
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** Date with time (isoformat) */
  DateTime: any;
  UUID: any;
  Upload: any;
  /** Represents NULL values */
  Void: any;
};

export type AddAudioFile = {
  description: Scalars["String"];
  file: Scalars["Upload"];
  fileName: Scalars["String"];
  name: Scalars["String"];
};

/**
 * A collection of :class:`~Node` and :class:`~Edge`.
 * This can be considered a score as well as a program as it
 * has an entry point as a :class:`~Node` and can jump to any
 * other :class:`~Node`, also allowing for recursive loops/cycles.
 *
 * Each node can be considered a little program on its own which can consist
 * of multiple :class:`~ScriptCell` which can be coded in a variety of
 * languages which can control the frontend and the audio (by e.g. speaking
 * on the stream) or setting a background music.
 *
 * The story graph is a core concept and can be edited with a native editor.
 */
export type AddGraphInput = {
  /** Text about the graph which can be accessed during a stream - only if this is set */
  aboutText?: InputMaybe<Scalars["String"]>;
  /** Will be used as a display name in the frontend */
  displayName: Scalars["String"];
  /** Text which will be displayed at the end of a stream */
  endText?: InputMaybe<Scalars["String"]>;
  /** Name of the graph */
  name: Scalars["String"];
  /** If the graph is not public it will not be listed in the frontend, yet it is still accessible via URL */
  publicVisible?: InputMaybe<Scalars["Boolean"]>;
  /** Will be used as a URL */
  slugName: Scalars["String"];
  /** Text about the graph which will be displayed at the start of a stream - only if this is set */
  startText?: InputMaybe<Scalars["String"]>;
  /** Manages the stream assignment for this graph */
  streamAssignmentPolicy?: InputMaybe<StreamAssignmentPolicy>;
  /** Allows to switch to a different template in the frontend with different connection flows or UI */
  templateName?: InputMaybe<GraphDetailTemplate>;
};

/** Stores information for playback of static audio files. */
export type AudioCell = {
  audioFile: AudioFile;
  playback: PlaybackChoices;
  uuid: Scalars["UUID"];
  volume: Scalars["Float"];
};

/** Stores information for playback of static audio files. */
export type AudioCellAudioFileArgs = {
  pagination?: InputMaybe<OffsetPaginationInput>;
};

/** Stores information for playback of static audio files. */
export type AudioCellInput = {
  audioFile: AudioFileReference;
  playback?: InputMaybe<PlaybackChoices>;
  uuid?: InputMaybe<Scalars["UUID"]>;
  volume?: InputMaybe<Scalars["Float"]>;
};

/**
 * Represents a local audio file on the server.
 * As SuperCollider and Django are running on the same server we
 * can pass these files to the SuperCollider instances as they
 * are mounted within each service.
 */
export type AudioFile = {
  /** Allows to separate automatic generated audio files speech to text and user uploads */
  autoGenerated: Scalars["Boolean"];
  createdDate: Scalars["DateTime"];
  description: Scalars["String"];
  file?: Maybe<DjangoFileType>;
  /** Acts as an identifier for humans */
  name: Scalars["String"];
  uuid: Scalars["UUID"];
};

/**
 * Represents a local audio file on the server.
 * As SuperCollider and Django are running on the same server we
 * can pass these files to the SuperCollider instances as they
 * are mounted within each service.
 */
export type AudioFileFilter = {
  /** Allows to separate automatic generated audio files speech to text and user uploads */
  autoGenerated?: InputMaybe<Scalars["Boolean"]>;
  description?: InputMaybe<StrFilterLookup>;
  /** Acts as an identifier for humans */
  name?: InputMaybe<StrFilterLookup>;
};

/**
 * Represents a local audio file on the server.
 * As SuperCollider and Django are running on the same server we
 * can pass these files to the SuperCollider instances as they
 * are mounted within each service.
 */
export type AudioFileReference = {
  uuid?: InputMaybe<Scalars["UUID"]>;
};

export type AudioFileUploadResponse = AudioFile | InvalidAudioFile;

/** A button which can also trigger a set of functionality. */
export type Button = {
  buttonType: ButtonType;
  callbackActions: Array<CallbackAction>;
  key: Scalars["String"];
  text: Scalars["String"];
  value: Scalars["String"];
};

/**
 * Derived from ElementPlus framework, see
 * `https://element-plus.org/en-US/component/button.html`_.
 */
export enum ButtonType {
  Danger = "DANGER",
  Default = "DEFAULT",
  Info = "INFO",
  Primary = "PRIMARY",
  Success = "SUCCESS",
  Warning = "WARNING",
}

/**
 * Allows to add a pre-defined JavaScript callback to a button or a checkbox.
 *
 * ACTIVATE_GPS_STREAMING          Activates streaming of GPS coordinates
 *                                 as :class:`~stream.models.StreamVariable`.
 *                                 If the GPS request succeeds the dialog will be closed,
 *                                 if not it the user will be forwarded to an error page
 *                                 which describes the setup procedure for the OS.
 * SEND_VARIABLES                  Send all variables of the form / dialog to
 *                                 the server.
 * SEND_VARIABLE                   Sends a single :class:`~stream.models.StreamVariable`
 *                                 with the key/value of the where the callback is
 *                                 attached to.
 */
export enum CallbackAction {
  ActivateGpsStreaming = "ACTIVATE_GPS_STREAMING",
  SendVariable = "SEND_VARIABLE",
  SendVariables = "SEND_VARIABLES",
}

/**
 * A :class:`~story_graph.models.ScriptCell` can contain
 * different types of code, each with unique functionality.
 *
 * Both, the database and :class:`~story_graph.engine.Engine`,
 * implement some specific details according to these types.
 *
 * .. list-table:: Cell types
 *     :header-rows: 1
 *
 *     * - Name
 *       - Description
 *       - Database
 *       - Engine
 *     * - Markdown
 *       - Allows to write arbitrary text which will get
 *         rendered as an audio file via a text to speech service,
 *         see :class:`~stream.models.TextToSpeech` for conversion
 *         and :class:`~story_graph.markdown_parser.GencasterRenderer`
 *         for the extended Markdown syntax.
 *       - - :class:`~stream.models.TextToSpeech`
 *       - - :func:`~story_graph.engine.Engine.execute_markdown_code`
 *         - :class:`~story_graph.markdown_parser.GencasterRenderer`
 *     * - Python
 *       - Allows to execute python code via :func:`exec` which allows
 *         to trigger e.g. Dialogs in the frontend
 *         (see :class:`~stream.frontend_types.Dialog`)
 *         or calculate or fetch any kind of data and store its value
 *         as a :class:`~stream.models.StreamVariable`.
 *       -
 *       - - :func:`~story_graph.engine.Engine.execute_python_cell`
 *     * - SuperCollider
 *       - Executes *sclang* code on the associated server.
 *         This can be used to control the sonic content on the server.
 *       - - :class:`~stream.models.StreamInstruction`
 *       - - :func:`~story_graph.engine.Engine.execute_sc_code`
 *         - :ref:`OSC Server`
 *     * - Comment
 *       - Does not get executed, but allows to put comments into
 *         the graph.
 *       -
 *       -
 *     * - Audio
 *       - Allows to playback static audio files.
 *         The instruction will be translated into *sclang* code and will
 *         be executed as such on the associated stream.
 *       - - :class:`~story_graph.models.AudioCell`
 *         - :class:`~stream.models.AudioFile`
 *       - - :func:`~story_graph.engine.Engine.execute_audio_cell`
 */
export enum CellType {
  Audio = "AUDIO",
  Comment = "COMMENT",
  Markdown = "MARKDOWN",
  Python = "PYTHON",
  Supercollider = "SUPERCOLLIDER",
}

/**
 * A classic ``<checkbox>`` whose state (``true``/``false``) will be
 * saved **as a string** under ``key`` in a :class:`~stream.models.StreamVariable`.
 */
export type Checkbox = {
  callbackActions: Array<CallbackAction>;
  checked: Scalars["Boolean"];
  key: Scalars["String"];
  label: Scalars["String"];
};

export type Content = Checkbox | Input | Text;

/** Triggers a popup on the frontend of the listener. */
export type Dialog = {
  buttons: Array<Button>;
  content: Array<Content>;
  title: Scalars["String"];
};

export type DjangoFileType = {
  name: Scalars["String"];
  path: Scalars["String"];
  size: Scalars["Int"];
  url: Scalars["String"];
};

/** An enumeration. */
export enum DoorType {
  Input = "INPUT",
  Output = "OUTPUT",
}

/**
 * Connects two :class:`~Node` with each other by
 * using their respective :class:`~NodeDoor`.
 *
 * .. important::
 *
 *     It is important to note that an edge flows from
 *     ``out_node_door`` to ``in_node_door`` as we follow
 *     the notion from the perspective of a
 *     :class:`story_graph.models.Node` rather than from the
 *     edge.
 *
 *
 * .. graphviz::
 *
 *     digraph Connection {
 *         rank = same;
 *         subgraph cluster_node_a {
 *             rank = same;
 *             label = "NODE_A";
 *             NODE_A [shape=Msquare, label="NODE_A\n\nscript_cell_1\nscript_cell_2"];
 *             subgraph cluster_in_nodes_a {
 *                 label = "IN_NODES";
 *                 in_node_door_a [label="in_node_door"];
 *             }
 *             subgraph cluster_out_nodes_a {
 *                 label = "OUT_NODES";
 *                 out_node_door_a_1 [label="out_node_door 1"];
 *                 out_node_door_a_2 [label="out_node_door 2"];
 *             }
 *             in_node_door_a -> NODE_A [label="DB\nreference"];
 *             {out_node_door_a_1, out_node_door_a_2} -> NODE_A;
 *             in_node_door_a -> NODE_A [style=dashed, color=red, fontcolor=red, label="Engine\nProgression"];
 *             NODE_A -> out_node_door_a_1 [style=dashed, color=red];
 *         }
 *
 *         edge_ [shape=Msquare, label="EDGE"];
 *         edge_ -> out_node_door_a_1 [label="out_node_door"];
 *         edge_ -> in_node_door_b [label="in_node_door"];
 *         out_node_door_a_1 -> edge_ [style=dashed, color=red];
 *         edge_ -> in_node_door_b [style=dashed, color=red];
 *
 *         subgraph cluster_node_b {
 *             rank = same;
 *             label = "NODE_B";
 *             NODE_B [shape=Msquare];
 *             subgraph cluster_in_nodes_b {
 *                 label = "IN_NODES";
 *                 in_node_door_b [label="in_node_door"];
 *             }
 *             subgraph cluster_out_nodes_b {
 *                 label = "OUT_NODES";
 *                 out_node_door_b_1 [label="out_node_door 1"];
 *                 out_node_door_b_2 [label="out_node_door 2"];
 *             }
 *             in_node_door_b -> NODE_B;
 *             {out_node_door_b_1, out_node_door_b_2} -> NODE_B;
 *             in_node_door_b -> NODE_B [style=dashed, color=red];
 *             NODE_B -> out_node_door_b_1 [style=dashed, color=red];
 *         }
 *     }
 */
export type Edge = {
  inNodeDoor?: Maybe<NodeDoor>;
  outNodeDoor?: Maybe<NodeDoor>;
  uuid: Scalars["UUID"];
};

export type EdgeInput = {
  nodeDoorInUuid: Scalars["UUID"];
  nodeDoorOutUuid: Scalars["UUID"];
};

/**
 * A collection of :class:`~Node` and :class:`~Edge`.
 * This can be considered a score as well as a program as it
 * has an entry point as a :class:`~Node` and can jump to any
 * other :class:`~Node`, also allowing for recursive loops/cycles.
 *
 * Each node can be considered a little program on its own which can consist
 * of multiple :class:`~ScriptCell` which can be coded in a variety of
 * languages which can control the frontend and the audio (by e.g. speaking
 * on the stream) or setting a background music.
 *
 * The story graph is a core concept and can be edited with a native editor.
 */
export type Graph = {
  /** Text about the graph which can be accessed during a stream - only if this is set */
  aboutText: Scalars["String"];
  /** Will be used as a display name in the frontend */
  displayName: Scalars["String"];
  edges: Array<Edge>;
  /** Text which will be displayed at the end of a stream */
  endText: Scalars["String"];
  /** Name of the graph */
  name: Scalars["String"];
  nodes: Array<Node>;
  /** If the graph is not public it will not be listed in the frontend, yet it is still accessible via URL */
  publicVisible: Scalars["Boolean"];
  /** Will be used as a URL */
  slugName: Scalars["String"];
  /** Text about the graph which will be displayed at the start of a stream - only if this is set */
  startText: Scalars["String"];
  /** Manages the stream assignment for this graph */
  streamAssignmentPolicy: StreamAssignmentPolicy;
  /** Allows to switch to a different template in the frontend with different connection flows or UI */
  templateName: GraphDetailTemplate;
  uuid: Scalars["UUID"];
};

/** Matches :class:`gencaster.story_graph.engine.GraphDeadEnd`. */
export type GraphDeadEnd = {
  error: Scalars["String"];
};

/** An enumeration. */
export enum GraphDetailTemplate {
  Default = "DEFAULT",
}

/**
 * A collection of :class:`~Node` and :class:`~Edge`.
 * This can be considered a score as well as a program as it
 * has an entry point as a :class:`~Node` and can jump to any
 * other :class:`~Node`, also allowing for recursive loops/cycles.
 *
 * Each node can be considered a little program on its own which can consist
 * of multiple :class:`~ScriptCell` which can be coded in a variety of
 * languages which can control the frontend and the audio (by e.g. speaking
 * on the stream) or setting a background music.
 *
 * The story graph is a core concept and can be edited with a native editor.
 */
export type GraphFilter = {
  /** Name of the graph */
  name?: InputMaybe<StrFilterLookup>;
  /** Will be used as a URL */
  slugName?: InputMaybe<StrFilterLookup>;
};

/**
 * A classic ``<inptut>`` which will save its content
 * under the ``key`` as a :class:`~stream.models.StreamVariable`.
 */
export type Input = {
  key: Scalars["String"];
  label: Scalars["String"];
  placeholder: Scalars["String"];
};

export type IntFilterLookup = {
  contains?: InputMaybe<Scalars["Int"]>;
  endsWith?: InputMaybe<Scalars["Int"]>;
  exact?: InputMaybe<Scalars["Int"]>;
  gt?: InputMaybe<Scalars["Int"]>;
  gte?: InputMaybe<Scalars["Int"]>;
  iContains?: InputMaybe<Scalars["Int"]>;
  iEndsWith?: InputMaybe<Scalars["Int"]>;
  iExact?: InputMaybe<Scalars["Int"]>;
  iRegex?: InputMaybe<Scalars["String"]>;
  iStartsWith?: InputMaybe<Scalars["Int"]>;
  inList?: InputMaybe<Array<Scalars["Int"]>>;
  isNull?: InputMaybe<Scalars["Boolean"]>;
  lt?: InputMaybe<Scalars["Int"]>;
  lte?: InputMaybe<Scalars["Int"]>;
  range?: InputMaybe<Array<Scalars["Int"]>>;
  regex?: InputMaybe<Scalars["String"]>;
  startsWith?: InputMaybe<Scalars["Int"]>;
};

/** Matches :class:`gencaster.stream.exceptions.InvalidAudioFile`. */
export type InvalidAudioFile = {
  error: Scalars["String"];
};

export type InvalidPythonCode = {
  errorCode: Scalars["String"];
  errorMessage: Scalars["String"];
  errorType: Scalars["String"];
};

export type LoginError = {
  errorMessage?: Maybe<Scalars["String"]>;
};

export type LoginRequestResponse = LoginError | User;

/** Mutations for Gencaster via GraphQL. */
export type Mutation = {
  addAudioFile: AudioFileUploadResponse;
  /**
   * Creates a :class:`~story_graph.models.Edge` for a given
   * :class:`~story_graph.models.Graph`.
   * It returns the created edge.
   */
  addEdge: Edge;
  addGraph: Graph;
  /**
   * Creates a new :class:`~story_graph.models.Node` in a given
   * ~class:`~story_graph.models.Graph`.
   * Although it creates a new node with UUID we don't hand it back yet.
   */
  addNode?: Maybe<Scalars["Void"]>;
  authLogin: LoginRequestResponse;
  authLogout: Scalars["Boolean"];
  createNodeDoor: NodeDoor;
  /** Creates or updates a given :class:`~story_graph.models.ScriptCell` to change its content. */
  createScriptCells: Array<ScriptCell>;
  createUpdateStreamVariable: Array<StreamVariable>;
  /** Deletes a given :class:`~story_graph.models.Edge`. */
  deleteEdge?: Maybe<Scalars["Void"]>;
  /** Deletes a given :class:`~story_graph.models.Node`. */
  deleteNode?: Maybe<Scalars["Void"]>;
  /**
   * Allows to delete a non-default NodeDoor.
   * If a node door was deleted it will return ``True``, otherwise ``False``.
   */
  deleteNodeDoor: Scalars["Boolean"];
  /** Deletes a given :class:`~story_graph.models.ScriptCell`. */
  deleteScriptCell?: Maybe<Scalars["Void"]>;
  /** Update metadata of an :class:`~stream.models.AudioFile` via a UUID */
  updateAudioFile: AudioFile;
  updateGraph: Graph;
  /**
   * Updates a given :class:`~story_graph.models.Node` which can be used
   * for renaming or moving it across the canvas.
   */
  updateNode?: Maybe<Scalars["Void"]>;
  updateNodeDoor: NodeDoorResponse;
  updateScriptCells: Array<ScriptCell>;
};

/** Mutations for Gencaster via GraphQL. */
export type MutationAddAudioFileArgs = {
  newAudioFile: AddAudioFile;
};

/** Mutations for Gencaster via GraphQL. */
export type MutationAddEdgeArgs = {
  newEdge: EdgeInput;
};

/** Mutations for Gencaster via GraphQL. */
export type MutationAddGraphArgs = {
  graphInput: AddGraphInput;
};

/** Mutations for Gencaster via GraphQL. */
export type MutationAddNodeArgs = {
  newNode: NodeCreate;
};

/** Mutations for Gencaster via GraphQL. */
export type MutationAuthLoginArgs = {
  password: Scalars["String"];
  username: Scalars["String"];
};

/** Mutations for Gencaster via GraphQL. */
export type MutationCreateNodeDoorArgs = {
  nodeDoorInput: NodeDoorInputCreate;
  nodeUuid: Scalars["UUID"];
};

/** Mutations for Gencaster via GraphQL. */
export type MutationCreateScriptCellsArgs = {
  nodeUuid: Scalars["UUID"];
  scriptCellInputs: Array<ScriptCellInputCreate>;
};

/** Mutations for Gencaster via GraphQL. */
export type MutationCreateUpdateStreamVariableArgs = {
  streamVariables: Array<StreamVariableInput>;
};

/** Mutations for Gencaster via GraphQL. */
export type MutationDeleteEdgeArgs = {
  edgeUuid: Scalars["UUID"];
};

/** Mutations for Gencaster via GraphQL. */
export type MutationDeleteNodeArgs = {
  nodeUuid: Scalars["UUID"];
};

/** Mutations for Gencaster via GraphQL. */
export type MutationDeleteNodeDoorArgs = {
  nodeDoorUuid: Scalars["UUID"];
};

/** Mutations for Gencaster via GraphQL. */
export type MutationDeleteScriptCellArgs = {
  scriptCellUuid: Scalars["UUID"];
};

/** Mutations for Gencaster via GraphQL. */
export type MutationUpdateAudioFileArgs = {
  updateAudioFile: UpdateAudioFile;
  uuid: Scalars["UUID"];
};

/** Mutations for Gencaster via GraphQL. */
export type MutationUpdateGraphArgs = {
  graphInput: UpdateGraphInput;
  graphUuid: Scalars["UUID"];
};

/** Mutations for Gencaster via GraphQL. */
export type MutationUpdateNodeArgs = {
  nodeUpdate: NodeUpdate;
};

/** Mutations for Gencaster via GraphQL. */
export type MutationUpdateNodeDoorArgs = {
  nodeDoorInput: NodeDoorInputUpdate;
};

/** Mutations for Gencaster via GraphQL. */
export type MutationUpdateScriptCellsArgs = {
  scriptCellInputs: Array<ScriptCellInputUpdate>;
};

/** Matches :class:`gencaster.stream.exceptions.NoStreamAvailable`. */
export type NoStreamAvailable = {
  error: Scalars["String"];
};

/** A node. */
export type Node = {
  color: Scalars["String"];
  inNodeDoors: Array<NodeDoor>;
  /** Acts as a singular entrypoint for our graph.Only one such node can exist per graph. */
  isEntryNode: Scalars["Boolean"];
  /** Name of the node */
  name: Scalars["String"];
  nodeDoors: Array<NodeDoor>;
  outNodeDoors: Array<NodeDoor>;
  /** x-Position in graph canvas */
  positionX: Scalars["Float"];
  /** y-Position in graph canvas */
  positionY: Scalars["Float"];
  scriptCells: Array<ScriptCell>;
  uuid: Scalars["UUID"];
};

export type NodeCreate = {
  color?: InputMaybe<Scalars["String"]>;
  graphUuid: Scalars["UUID"];
  name: Scalars["String"];
  positionX?: InputMaybe<Scalars["Float"]>;
  positionY?: InputMaybe<Scalars["Float"]>;
};

/**
 * A :class:`~Node` can be entered and exited via
 * multiple paths, where each of these exits and
 * entrances is called a *door*.
 *
 * A connection between nodes can only be made via their
 * doors.
 * There are two types of doors:
 *
 * .. list-table:: Door types
 *     :header-rows: 1
 *
 *     * - Kind
 *       - Description
 *     * - **INPUT**
 *       - Allows to enter a node.
 *         Currently each Node only has one entry point
 *         but for future development and a nicer
 *         database operations it is also represented.
 *     * - **OUTPUT**
 *       - Allows to exit a node.
 *         After all script cells of a node has been
 *         executed, the condition of each door will
 *         be evaluated (like in a switch case).
 *         Once a condition has been met, the door
 *         will be stepped through.
 *         This allows to have a visual representation
 *         of logic branches.
 *
 * It is only possible to connect an **OUTPUT** to an
 * **INPUT** door via an :class:`~Edge`.
 */
export type NodeDoor = {
  code: Scalars["String"];
  doorType: DoorType;
  isDefault: Scalars["Boolean"];
  name: Scalars["String"];
  node: Node;
  order: Scalars["Int"];
  uuid: Scalars["UUID"];
};

/**
 * A :class:`~Node` can be entered and exited via
 * multiple paths, where each of these exits and
 * entrances is called a *door*.
 *
 * A connection between nodes can only be made via their
 * doors.
 * There are two types of doors:
 *
 * .. list-table:: Door types
 *     :header-rows: 1
 *
 *     * - Kind
 *       - Description
 *     * - **INPUT**
 *       - Allows to enter a node.
 *         Currently each Node only has one entry point
 *         but for future development and a nicer
 *         database operations it is also represented.
 *     * - **OUTPUT**
 *       - Allows to exit a node.
 *         After all script cells of a node has been
 *         executed, the condition of each door will
 *         be evaluated (like in a switch case).
 *         Once a condition has been met, the door
 *         will be stepped through.
 *         This allows to have a visual representation
 *         of logic branches.
 *
 * It is only possible to connect an **OUTPUT** to an
 * **INPUT** door via an :class:`~Edge`.
 */
export type NodeDoorInputCreate = {
  code?: InputMaybe<Scalars["String"]>;
  doorType?: InputMaybe<DoorType>;
  name: Scalars["String"];
  order?: InputMaybe<Scalars["Int"]>;
};

export type NodeDoorInputUpdate = {
  code?: InputMaybe<Scalars["String"]>;
  doorType?: DoorType;
  name?: InputMaybe<Scalars["String"]>;
  order?: InputMaybe<Scalars["Int"]>;
  uuid: Scalars["UUID"];
};

export type NodeDoorResponse = InvalidPythonCode | NodeDoor;

export type NodeUpdate = {
  color?: InputMaybe<Scalars["String"]>;
  name?: InputMaybe<Scalars["String"]>;
  positionX?: InputMaybe<Scalars["Float"]>;
  positionY?: InputMaybe<Scalars["Float"]>;
  uuid: Scalars["UUID"];
};

export type OffsetPaginationInput = {
  limit?: Scalars["Int"];
  offset?: Scalars["Int"];
};

/**
 * Different kinds of playback.
 *
 * .. list-table:: Playback types
 *     :header-rows: 1
 *
 *     * - Name
 *       - Description
 *     * - ``SYNC``
 *       - Plays back an audio file and waits for the
 *         playback to finish before continuing the
 *         execution of the script cells.
 *     * - ``ASYNC``
 *       - Plays back an audio file and immediately
 *         continues the execution of script cells.
 *         This is fitting for e.g. background music.
 */
export enum PlaybackChoices {
  AsyncPlayback = "ASYNC_PLAYBACK",
  SyncPlayback = "SYNC_PLAYBACK",
}

/** Queries for Gencaster. */
export type Query = {
  audioFile: AudioFile;
  audioFiles: Array<AudioFile>;
  graph: Graph;
  graphs: Array<Graph>;
  isAuthenticated?: Maybe<User>;
  node: Node;
  nodes: Array<Node>;
  streamPoint: StreamPoint;
  streamPoints: Array<StreamPoint>;
  streamVariable: StreamVariable;
};

/** Queries for Gencaster. */
export type QueryAudioFileArgs = {
  pagination?: InputMaybe<OffsetPaginationInput>;
  pk: Scalars["ID"];
};

/** Queries for Gencaster. */
export type QueryAudioFilesArgs = {
  filters?: InputMaybe<AudioFileFilter>;
  pagination?: InputMaybe<OffsetPaginationInput>;
};

/** Queries for Gencaster. */
export type QueryGraphArgs = {
  pk: Scalars["ID"];
};

/** Queries for Gencaster. */
export type QueryGraphsArgs = {
  filters?: InputMaybe<GraphFilter>;
};

/** Queries for Gencaster. */
export type QueryNodeArgs = {
  pk: Scalars["ID"];
};

/** Queries for Gencaster. */
export type QueryStreamPointArgs = {
  pk: Scalars["ID"];
};

/** Queries for Gencaster. */
export type QueryStreamPointsArgs = {
  filters?: InputMaybe<StreamPointFilter>;
};

/** Queries for Gencaster. */
export type QueryStreamVariableArgs = {
  pk: Scalars["ID"];
};

/**
 * Stores a script which can be executed
 * with our :class:`~story_graph.engine.Engine` on a
 * :class:`~stream.models.Stream`.
 */
export type ScriptCell = {
  audioCell?: Maybe<AudioCell>;
  cellCode: Scalars["String"];
  cellOrder: Scalars["Int"];
  cellType: CellType;
  node: Node;
  uuid: Scalars["UUID"];
};

/**
 * Stores a script which can be executed
 * with our :class:`~story_graph.engine.Engine` on a
 * :class:`~stream.models.Stream`.
 */
export type ScriptCellInputCreate = {
  audioCell?: InputMaybe<AudioCellInput>;
  cellCode: Scalars["String"];
  cellOrder?: InputMaybe<Scalars["Int"]>;
  cellType?: InputMaybe<CellType>;
};

/**
 * Stores a script which can be executed
 * with our :class:`~story_graph.engine.Engine` on a
 * :class:`~stream.models.Stream`.
 */
export type ScriptCellInputUpdate = {
  audioCell?: InputMaybe<AudioCellInput>;
  cellCode?: InputMaybe<Scalars["String"]>;
  cellOrder?: InputMaybe<Scalars["Int"]>;
  cellType?: InputMaybe<CellType>;
  uuid?: InputMaybe<Scalars["UUID"]>;
};

export type StrFilterLookup = {
  contains?: InputMaybe<Scalars["String"]>;
  endsWith?: InputMaybe<Scalars["String"]>;
  exact?: InputMaybe<Scalars["String"]>;
  gt?: InputMaybe<Scalars["String"]>;
  gte?: InputMaybe<Scalars["String"]>;
  iContains?: InputMaybe<Scalars["String"]>;
  iEndsWith?: InputMaybe<Scalars["String"]>;
  iExact?: InputMaybe<Scalars["String"]>;
  iRegex?: InputMaybe<Scalars["String"]>;
  iStartsWith?: InputMaybe<Scalars["String"]>;
  inList?: InputMaybe<Array<Scalars["String"]>>;
  isNull?: InputMaybe<Scalars["Boolean"]>;
  lt?: InputMaybe<Scalars["String"]>;
  lte?: InputMaybe<Scalars["String"]>;
  range?: InputMaybe<Array<Scalars["String"]>>;
  regex?: InputMaybe<Scalars["String"]>;
  startsWith?: InputMaybe<Scalars["String"]>;
};

/**
 * Assigns a :class:`~StreamPoint` to a user/client.
 * This allows us to see which streams are currently in use
 * and also by which user.
 * It also allows us to trace past streams.
 */
export type Stream = {
  createdDate: Scalars["DateTime"];
  modifiedDate: Scalars["DateTime"];
  /** Used as a garbage collection. If multiple users share the same stream we need to know when we can release the stream which happens if listener counter is 0. It starts with a default of 0 because this allows us to count stateless. */
  numListeners: Scalars["Int"];
  streamPoint: StreamPoint;
  uuid: Scalars["UUID"];
};

/** An enumeration. */
export enum StreamAssignmentPolicy {
  Deactivate = "DEACTIVATE",
  OneGraphOneStream = "ONE_GRAPH_ONE_STREAM",
  OneUserOneStream = "ONE_USER_ONE_STREAM",
}

export type StreamInfo = {
  stream: Stream;
  streamInstruction?: Maybe<StreamInstruction>;
};

export type StreamInfoResponse =
  | Dialog
  | GraphDeadEnd
  | NoStreamAvailable
  | StreamInfo;

/**
 * Instruction for a :class:`StreamPoint`, most likely to be
 * created from a :class:`~story_graph.models.ScriptCell`.
 */
export type StreamInstruction = {
  createdDate: Scalars["DateTime"];
  frontendDisplay: Dialog;
  instructionText: Scalars["String"];
  modifiedDate: Scalars["DateTime"];
  returnValue: Scalars["String"];
  state: Scalars["String"];
  uuid: Scalars["UUID"];
};

/** StreamLog(uuid, created_date, modified_date, stream_point, stream, origin, level, message, name) */
export type StreamLog = {
  createdDate: Scalars["DateTime"];
  level: Scalars["Int"];
  message: Scalars["String"];
  name?: Maybe<Scalars["String"]>;
  origin?: Maybe<Scalars["String"]>;
  stream?: Maybe<Stream>;
  streamPoint?: Maybe<StreamPoint>;
  uuid: Scalars["UUID"];
};

/**
 * Stores metadata for each SuperCollider/Janus instance
 * and how we can interact with this instance.
 *
 * Every SuperCollider instance that send a beacon to us
 * via the :ref:`OSC Server` will be a StreamPoint.
 * Consider ``last_live`` to filter out non-live from live
 * instances.
 */
export type StreamPoint = {
  createdDate: Scalars["DateTime"];
  host: Scalars["String"];
  /** RTP port where Janus streams the audio its received from user */
  janusInPort?: Maybe<Scalars["Int"]>;
  /** Audiobridge room ID under which Janus can send audio to SuperCollider */
  janusInRoom?: Maybe<Scalars["Int"]>;
  /** RTP port where SuperCollider/gstreamer streams its audio to Janus */
  janusOutPort?: Maybe<Scalars["Int"]>;
  /** Streaming room ID under which Janus serves audio from SuperCollider */
  janusOutRoom?: Maybe<Scalars["Int"]>;
  /** Last live signal from SuperCollider server */
  lastLive?: Maybe<Scalars["DateTime"]>;
  modifiedDate: Scalars["DateTime"];
  port: Scalars["Int"];
  /** Accepts to send audio input */
  useInput: Scalars["Boolean"];
  uuid: Scalars["UUID"];
};

/**
 * Stores metadata for each SuperCollider/Janus instance
 * and how we can interact with this instance.
 *
 * Every SuperCollider instance that send a beacon to us
 * via the :ref:`OSC Server` will be a StreamPoint.
 * Consider ``last_live`` to filter out non-live from live
 * instances.
 */
export type StreamPointFilter = {
  /** RTP port where Janus streams the audio its received from user */
  janusInPort?: InputMaybe<IntFilterLookup>;
  uuid?: InputMaybe<UuidFilterLookup>;
};

/**
 * Allows to store variables in a stream session as a key/value pair.
 *
 * .. warning::
 *
 *     Due to database constraints all keys and values will be stored
 *     as a string, so parsing a float, int or boolean requires
 *     type conversion.
 */
export type StreamVariable = {
  key: Scalars["String"];
  stream: Stream;
  /** Stream values to SC as control rate Ndef */
  streamToSc: Scalars["Boolean"];
  uuid: Scalars["UUID"];
  value: Scalars["String"];
};

export type StreamVariableInput = {
  key: Scalars["String"];
  streamToSc?: Scalars["Boolean"];
  streamUuid: Scalars["UUID"];
  value: Scalars["String"];
};

export type Subscription = {
  /**
   * Used within the editor to synchronize any updates of the graph such as movement
   * of a :class:`~story_graph.models.Node`.
   */
  graph: Graph;
  /**
   * Used within the editor to synchronize any updates on a node such as updates on a
   * :class:`~story_graph.models.ScriptCell`.
   */
  node: Node;
  /**
   * Used within the frontend to attach a user to a stream.
   * :class:`~story_graph.engine.Engine` contains the specifics of how the iteration over a
   * graph is handled.
   *
   * Upon visit the ``num_of_listeners`` of the associated
   * :class:~stream.models.Stream` will be incremented which indicates
   * if a given stream is free or used.
   * Upon connection stop this will be decremented again.
   */
  streamInfo: StreamInfoResponse;
  streamLogs: StreamLog;
  streams: Array<Stream>;
};

export type SubscriptionGraphArgs = {
  graphUuid: Scalars["UUID"];
};

export type SubscriptionNodeArgs = {
  nodeUuid: Scalars["UUID"];
};

export type SubscriptionStreamInfoArgs = {
  graphUuid: Scalars["UUID"];
};

export type SubscriptionStreamLogsArgs = {
  streamPointUuid?: InputMaybe<Scalars["UUID"]>;
  streamUuid?: InputMaybe<Scalars["UUID"]>;
};

export type SubscriptionStreamsArgs = {
  limit?: Scalars["Int"];
};

/** Displays plain text. */
export type Text = {
  text: Scalars["String"];
};

export type UuidFilterLookup = {
  contains?: InputMaybe<Scalars["UUID"]>;
  endsWith?: InputMaybe<Scalars["UUID"]>;
  exact?: InputMaybe<Scalars["UUID"]>;
  gt?: InputMaybe<Scalars["UUID"]>;
  gte?: InputMaybe<Scalars["UUID"]>;
  iContains?: InputMaybe<Scalars["UUID"]>;
  iEndsWith?: InputMaybe<Scalars["UUID"]>;
  iExact?: InputMaybe<Scalars["UUID"]>;
  iRegex?: InputMaybe<Scalars["String"]>;
  iStartsWith?: InputMaybe<Scalars["UUID"]>;
  inList?: InputMaybe<Array<Scalars["UUID"]>>;
  isNull?: InputMaybe<Scalars["Boolean"]>;
  lt?: InputMaybe<Scalars["UUID"]>;
  lte?: InputMaybe<Scalars["UUID"]>;
  range?: InputMaybe<Array<Scalars["UUID"]>>;
  regex?: InputMaybe<Scalars["String"]>;
  startsWith?: InputMaybe<Scalars["UUID"]>;
};

export type UpdateAudioFile = {
  description?: InputMaybe<Scalars["String"]>;
  name?: InputMaybe<Scalars["String"]>;
};

/**
 * A collection of :class:`~Node` and :class:`~Edge`.
 * This can be considered a score as well as a program as it
 * has an entry point as a :class:`~Node` and can jump to any
 * other :class:`~Node`, also allowing for recursive loops/cycles.
 *
 * Each node can be considered a little program on its own which can consist
 * of multiple :class:`~ScriptCell` which can be coded in a variety of
 * languages which can control the frontend and the audio (by e.g. speaking
 * on the stream) or setting a background music.
 *
 * The story graph is a core concept and can be edited with a native editor.
 */
export type UpdateGraphInput = {
  /** Text about the graph which can be accessed during a stream - only if this is set */
  aboutText?: InputMaybe<Scalars["String"]>;
  /** Will be used as a display name in the frontend */
  displayName?: InputMaybe<Scalars["String"]>;
  /** Text which will be displayed at the end of a stream */
  endText?: InputMaybe<Scalars["String"]>;
  /** Name of the graph */
  name?: InputMaybe<Scalars["String"]>;
  /** If the graph is not public it will not be listed in the frontend, yet it is still accessible via URL */
  publicVisible?: InputMaybe<Scalars["Boolean"]>;
  /** Text about the graph which will be displayed at the start of a stream - only if this is set */
  startText?: InputMaybe<Scalars["String"]>;
  /** Manages the stream assignment for this graph */
  streamAssignmentPolicy?: InputMaybe<StreamAssignmentPolicy>;
  /** Allows to switch to a different template in the frontend with different connection flows or UI */
  templateName?: InputMaybe<GraphDetailTemplate>;
};

/**
 * Users within the Django authentication system are represented by this
 * model.
 *
 * Username and password are required. Other fields are optional.
 */
export type User = {
  email: Scalars["String"];
  firstName: Scalars["String"];
  /** Designates whether this user should be treated as active. Unselect this instead of deleting accounts. */
  isActive: Scalars["Boolean"];
  /** Designates whether the user can log into this admin site. */
  isStaff: Scalars["Boolean"];
  lastName: Scalars["String"];
  /** Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. */
  username: Scalars["String"];
};

export type FullStreamInfoFragment = {
  __typename: "StreamInfo";
  stream: {
    numListeners: number;
    createdDate: any;
    modifiedDate: any;
    uuid: any;
    streamPoint: {
      uuid: any;
      port: number;
      useInput: boolean;
      modifiedDate: any;
      lastLive?: any | null;
      host: string;
      createdDate: any;
      janusInPort?: number | null;
      janusInRoom?: number | null;
      janusOutPort?: number | null;
      janusOutRoom?: number | null;
    };
  };
};

export type UserInfoFragment = {
  __typename: "User";
  email: string;
  firstName: string;
  isActive: boolean;
  isStaff: boolean;
  lastName: string;
  username: string;
};

export type AudioFileInfoFragment = {
  autoGenerated: boolean;
  createdDate: any;
  description: string;
  name: string;
  uuid: any;
  file?: { name: string; path: string; size: number; url: string } | null;
};

export type GetGraphsQueryVariables = Exact<{
  name?: InputMaybe<Scalars["String"]>;
}>;

export type GetGraphsQuery = {
  graphs: Array<{
    uuid: any;
    name: string;
    slugName: string;
    templateName: GraphDetailTemplate;
  }>;
};

export type GetGraphsMetaQueryVariables = Exact<{
  slug: Scalars["String"];
}>;

export type GetGraphsMetaQuery = {
  graphs: Array<{
    aboutText: string;
    displayName: string;
    endText: string;
    name: string;
    startText: string;
    templateName: GraphDetailTemplate;
    uuid: any;
    slugName: string;
  }>;
};

export type CreateEdgeMutationVariables = Exact<{
  nodeDoorInUuid: Scalars["UUID"];
  nodeDoorOutUuid: Scalars["UUID"];
}>;

export type CreateEdgeMutation = { addEdge: { uuid: any } };

export type CreateNodeMutationVariables = Exact<{
  name: Scalars["String"];
  graphUuid: Scalars["UUID"];
  color?: InputMaybe<Scalars["String"]>;
  positionX?: InputMaybe<Scalars["Float"]>;
  positionY?: InputMaybe<Scalars["Float"]>;
}>;

export type CreateNodeMutation = { addNode?: any | null };

export type UpdateNodeMutationVariables = Exact<{
  nodeUuid: Scalars["UUID"];
  name?: InputMaybe<Scalars["String"]>;
  color?: InputMaybe<Scalars["String"]>;
  positionX?: InputMaybe<Scalars["Float"]>;
  positionY?: InputMaybe<Scalars["Float"]>;
}>;

export type UpdateNodeMutation = { updateNode?: any | null };

export type DeleteNodeMutationVariables = Exact<{
  nodeUuid: Scalars["UUID"];
}>;

export type DeleteNodeMutation = { deleteNode?: any | null };

export type DeleteEdgeMutationVariables = Exact<{
  edgeUuid: Scalars["UUID"];
}>;

export type DeleteEdgeMutation = { deleteEdge?: any | null };

export type CreateScriptCellsMutationVariables = Exact<{
  nodeUuid: Scalars["UUID"];
  scriptCellInputs: Array<ScriptCellInputCreate> | ScriptCellInputCreate;
}>;

export type CreateScriptCellsMutation = {
  createScriptCells: Array<{ uuid: any }>;
};

export type UpdateScriptCellsMutationVariables = Exact<{
  scriptCellInputs: Array<ScriptCellInputUpdate> | ScriptCellInputUpdate;
}>;

export type UpdateScriptCellsMutation = {
  updateScriptCells: Array<{ uuid: any }>;
};

export type DeleteScriptCellMutationVariables = Exact<{
  scriptCellUuid: Scalars["UUID"];
}>;

export type DeleteScriptCellMutation = { deleteScriptCell?: any | null };

export type NodeDoorBasicFragment = {
  uuid: any;
  name: string;
  order: number;
  isDefault: boolean;
  node: { uuid: any };
};

export type GraphSubscriptionVariables = Exact<{
  uuid: Scalars["UUID"];
}>;

export type GraphSubscription = {
  graph: {
    name: string;
    slugName: string;
    uuid: any;
    edges: Array<{
      uuid: any;
      inNodeDoor?: {
        uuid: any;
        name: string;
        order: number;
        isDefault: boolean;
        node: { uuid: any };
      } | null;
      outNodeDoor?: {
        uuid: any;
        name: string;
        order: number;
        isDefault: boolean;
        node: { uuid: any };
      } | null;
    }>;
    nodes: Array<{
      name: string;
      uuid: any;
      positionX: number;
      positionY: number;
      color: string;
      isEntryNode: boolean;
      scriptCells: Array<{
        cellCode: string;
        cellOrder: number;
        cellType: CellType;
        uuid: any;
      }>;
      inNodeDoors: Array<{
        uuid: any;
        name: string;
        order: number;
        isDefault: boolean;
        node: { uuid: any };
      }>;
      outNodeDoors: Array<{
        uuid: any;
        name: string;
        order: number;
        isDefault: boolean;
        node: { uuid: any };
      }>;
    }>;
  };
};

export type NodeDoorDetailFragment = {
  uuid: any;
  name: string;
  order: number;
  isDefault: boolean;
  code: string;
  doorType: DoorType;
};

export type NodeSubscriptionVariables = Exact<{
  uuid: Scalars["UUID"];
}>;

export type NodeSubscription = {
  node: {
    color: string;
    name: string;
    positionX: number;
    positionY: number;
    isEntryNode: boolean;
    uuid: any;
    inNodeDoors: Array<{
      uuid: any;
      name: string;
      order: number;
      isDefault: boolean;
      code: string;
      doorType: DoorType;
    }>;
    outNodeDoors: Array<{
      uuid: any;
      name: string;
      order: number;
      isDefault: boolean;
      code: string;
      doorType: DoorType;
    }>;
    scriptCells: Array<{
      cellCode: string;
      cellOrder: number;
      cellType: CellType;
      uuid: any;
      audioCell?: {
        playback: PlaybackChoices;
        uuid: any;
        volume: number;
        audioFile: {
          uuid: any;
          name: string;
          autoGenerated: boolean;
          description: string;
          file?: { url: string; name: string } | null;
        };
      } | null;
    }>;
  };
};

export type GraphMetaDataFragment = {
  uuid: any;
  templateName: GraphDetailTemplate;
  startText: string;
  slugName: string;
  name: string;
  endText: string;
  displayName: string;
  aboutText: string;
  streamAssignmentPolicy: StreamAssignmentPolicy;
  publicVisible: boolean;
};

export type GetGraphQueryVariables = Exact<{
  graphUuid: Scalars["ID"];
}>;

export type GetGraphQuery = {
  graph: {
    uuid: any;
    templateName: GraphDetailTemplate;
    startText: string;
    slugName: string;
    name: string;
    endText: string;
    displayName: string;
    aboutText: string;
    streamAssignmentPolicy: StreamAssignmentPolicy;
    publicVisible: boolean;
  };
};

export type CreateGraphMutationVariables = Exact<{
  graphInput: AddGraphInput;
}>;

export type CreateGraphMutation = {
  addGraph: {
    name: string;
    uuid: any;
    nodes: Array<{ name: string; uuid: any; isEntryNode: boolean }>;
  };
};

export type UpdateGraphMutationVariables = Exact<{
  graphUuid: Scalars["UUID"];
  graphUpdate: UpdateGraphInput;
}>;

export type UpdateGraphMutation = { updateGraph: { uuid: any } };

export type StreamSubscriptionVariables = Exact<{
  graphUuid: Scalars["UUID"];
}>;

export type StreamSubscription = {
  streamInfo:
    | {
        __typename: "Dialog";
        title: string;
        content: Array<
          | {
              __typename: "Checkbox";
              checked: boolean;
              label: string;
              key: string;
              callbackActions: Array<CallbackAction>;
            }
          | {
              __typename: "Input";
              label: string;
              placeholder: string;
              key: string;
            }
          | { __typename: "Text"; text: string }
        >;
        buttons: Array<{
          __typename: "Button";
          buttonType: ButtonType;
          text: string;
          key: string;
          callbackActions: Array<CallbackAction>;
          value: string;
        }>;
      }
    | { __typename: "GraphDeadEnd"; error: string }
    | { __typename: "NoStreamAvailable"; error: string }
    | {
        __typename: "StreamInfo";
        streamInstruction?: {
          createdDate: any;
          instructionText: string;
          modifiedDate: any;
          state: string;
          uuid: any;
          returnValue: string;
        } | null;
        stream: {
          numListeners: number;
          createdDate: any;
          modifiedDate: any;
          uuid: any;
          streamPoint: {
            uuid: any;
            port: number;
            useInput: boolean;
            modifiedDate: any;
            lastLive?: any | null;
            host: string;
            createdDate: any;
            janusInPort?: number | null;
            janusInRoom?: number | null;
            janusOutPort?: number | null;
            janusOutRoom?: number | null;
          };
        };
      };
};

export type StreamPointsQueryVariables = Exact<{ [key: string]: never }>;

export type StreamPointsQuery = {
  streamPoints: Array<{
    createdDate: any;
    host: string;
    janusInPort?: number | null;
    janusInRoom?: number | null;
    janusOutPort?: number | null;
    janusOutRoom?: number | null;
    lastLive?: any | null;
    modifiedDate: any;
    port: number;
    useInput: boolean;
    uuid: any;
  }>;
};

export type UploadAudioFileMutationVariables = Exact<{
  addAudioFile: AddAudioFile;
}>;

export type UploadAudioFileMutation = {
  addAudioFile:
    | {
        __typename: "AudioFile";
        autoGenerated: boolean;
        createdDate: any;
        description: string;
        name: string;
        uuid: any;
        file?: { name: string; path: string; size: number; url: string } | null;
      }
    | { __typename: "InvalidAudioFile"; error: string };
};

export type SendStreamVariableMutationVariables = Exact<{
  streamVariables: Array<StreamVariableInput> | StreamVariableInput;
}>;

export type SendStreamVariableMutation = {
  createUpdateStreamVariable: Array<{ uuid: any; value: string }>;
};

export type AudioFilesQueryVariables = Exact<{
  autoGenerated?: Scalars["Boolean"];
  audioNameFilter?: Scalars["String"];
  limit?: InputMaybe<Scalars["Int"]>;
  offset?: InputMaybe<Scalars["Int"]>;
}>;

export type AudioFilesQuery = {
  audioFiles: Array<{
    autoGenerated: boolean;
    createdDate: any;
    description: string;
    name: string;
    uuid: any;
    file?: { name: string; path: string; size: number; url: string } | null;
  }>;
};

export type IsAuthenticatedQueryVariables = Exact<{ [key: string]: never }>;

export type IsAuthenticatedQuery = {
  isAuthenticated?: {
    __typename: "User";
    email: string;
    firstName: string;
    isActive: boolean;
    isStaff: boolean;
    lastName: string;
    username: string;
  } | null;
};

export type LoginUserMutationVariables = Exact<{
  username: Scalars["String"];
  password: Scalars["String"];
}>;

export type LoginUserMutation = {
  authLogin:
    | { __typename: "LoginError"; errorMessage?: string | null }
    | {
        __typename: "User";
        email: string;
        firstName: string;
        isActive: boolean;
        isStaff: boolean;
        lastName: string;
        username: string;
      };
};

export type LogoutMutationVariables = Exact<{ [key: string]: never }>;

export type LogoutMutation = { authLogout: boolean };

export type UpdateAudioFileMutationVariables = Exact<{
  uuid: Scalars["UUID"];
  updateAudioFile: UpdateAudioFile;
}>;

export type UpdateAudioFileMutation = {
  updateAudioFile: {
    autoGenerated: boolean;
    createdDate: any;
    description: string;
    name: string;
    uuid: any;
    file?: { name: string; path: string; size: number; url: string } | null;
  };
};

export type StreamInfoFragmentFragment = {
  uuid: any;
  numListeners: number;
  modifiedDate: any;
  createdDate: any;
  streamPoint: {
    createdDate: any;
    host: string;
    janusInPort?: number | null;
    janusInRoom?: number | null;
    janusOutPort?: number | null;
    janusOutRoom?: number | null;
    lastLive?: any | null;
    modifiedDate: any;
    port: number;
    useInput: boolean;
    uuid: any;
  };
};

export type StreamsSubscriptionVariables = Exact<{
  numOfStreams?: InputMaybe<Scalars["Int"]>;
}>;

export type StreamsSubscription = {
  streams: Array<{
    uuid: any;
    numListeners: number;
    modifiedDate: any;
    createdDate: any;
    streamPoint: {
      createdDate: any;
      host: string;
      janusInPort?: number | null;
      janusInRoom?: number | null;
      janusOutPort?: number | null;
      janusOutRoom?: number | null;
      lastLive?: any | null;
      modifiedDate: any;
      port: number;
      useInput: boolean;
      uuid: any;
    };
  }>;
};

export type StreamLogsSubscriptionVariables = Exact<{
  streamUuid?: InputMaybe<Scalars["UUID"]>;
  streamPointUuid?: InputMaybe<Scalars["UUID"]>;
}>;

export type StreamLogsSubscription = {
  streamLogs: {
    createdDate: any;
    level: number;
    message: string;
    name?: string | null;
    uuid: any;
    stream?: { uuid: any } | null;
    streamPoint?: { uuid: any } | null;
  };
};

export type CreateNodeDoorMutationVariables = Exact<{
  nodeUuid: Scalars["UUID"];
  name: Scalars["String"];
  code?: Scalars["String"];
  doorType?: InputMaybe<DoorType>;
  order?: InputMaybe<Scalars["Int"]>;
}>;

export type CreateNodeDoorMutation = { createNodeDoor: { uuid: any } };

export type DeleteNodeDoorMutationVariables = Exact<{
  nodeDoorUuid: Scalars["UUID"];
}>;

export type DeleteNodeDoorMutation = { deleteNodeDoor: boolean };

export type UpdateNodeDoorMutationVariables = Exact<{
  uuid: Scalars["UUID"];
  name?: InputMaybe<Scalars["String"]>;
  code?: InputMaybe<Scalars["String"]>;
  order?: InputMaybe<Scalars["Int"]>;
}>;

export type UpdateNodeDoorMutation = {
  updateNodeDoor:
    | {
        __typename: "InvalidPythonCode";
        errorCode: string;
        errorMessage: string;
        errorType: string;
      }
    | { __typename: "NodeDoor"; uuid: any };
};

export const FullStreamInfoFragmentDoc = gql`
  fragment FullStreamInfo on StreamInfo {
    __typename
    stream {
      numListeners
      createdDate
      modifiedDate
      streamPoint {
        uuid
        port
        useInput
        modifiedDate
        lastLive
        host
        createdDate
        janusInPort
        janusInRoom
        janusOutPort
        janusOutRoom
      }
      uuid
    }
  }
`;
export const UserInfoFragmentDoc = gql`
  fragment UserInfo on User {
    __typename
    email
    firstName
    isActive
    isStaff
    lastName
    username
  }
`;
export const AudioFileInfoFragmentDoc = gql`
  fragment AudioFileInfo on AudioFile {
    autoGenerated
    createdDate
    description
    name
    uuid
    file {
      name
      path
      size
      url
    }
  }
`;
export const NodeDoorBasicFragmentDoc = gql`
  fragment NodeDoorBasic on NodeDoor {
    uuid
    name
    order
    isDefault
    node {
      uuid
    }
  }
`;
export const NodeDoorDetailFragmentDoc = gql`
  fragment NodeDoorDetail on NodeDoor {
    uuid
    name
    order
    isDefault
    code
    doorType
  }
`;
export const GraphMetaDataFragmentDoc = gql`
  fragment GraphMetaData on Graph {
    uuid
    templateName
    startText
    slugName
    name
    endText
    displayName
    aboutText
    streamAssignmentPolicy
    publicVisible
  }
`;
export const StreamInfoFragmentFragmentDoc = gql`
  fragment StreamInfoFragment on Stream {
    uuid
    numListeners
    modifiedDate
    createdDate
    streamPoint {
      createdDate
      host
      janusInPort
      janusInRoom
      janusOutPort
      janusOutRoom
      lastLive
      modifiedDate
      port
      useInput
      uuid
    }
  }
`;
export const GetGraphsDocument = gql`
  query GetGraphs($name: String) {
    graphs(filters: { name: { iContains: $name } }) {
      uuid
      name
      slugName
      templateName
    }
  }
`;

export function useGetGraphsQuery(
  options: Omit<Urql.UseQueryArgs<never, GetGraphsQueryVariables>, "query"> = {},
) {
  return Urql.useQuery<GetGraphsQuery>({
    query: GetGraphsDocument,
    ...options,
  });
}
export const GetGraphsMetaDocument = gql`
  query GetGraphsMeta($slug: String!) {
    graphs(filters: { slugName: { exact: $slug } }) {
      aboutText
      displayName
      endText
      name
      startText
      templateName
      uuid
      slugName
    }
  }
`;

export function useGetGraphsMetaQuery(
  options: Omit<
    Urql.UseQueryArgs<never, GetGraphsMetaQueryVariables>,
    "query"
  > = {},
) {
  return Urql.useQuery<GetGraphsMetaQuery>({
    query: GetGraphsMetaDocument,
    ...options,
  });
}
export const CreateEdgeDocument = gql`
  mutation createEdge($nodeDoorInUuid: UUID!, $nodeDoorOutUuid: UUID!) {
    addEdge(
      newEdge: {
        nodeDoorInUuid: $nodeDoorInUuid
        nodeDoorOutUuid: $nodeDoorOutUuid
      }
    ) {
      uuid
    }
  }
`;

export function useCreateEdgeMutation() {
  return Urql.useMutation<CreateEdgeMutation, CreateEdgeMutationVariables>(
    CreateEdgeDocument,
  );
}
export const CreateNodeDocument = gql`
  mutation createNode(
    $name: String!
    $graphUuid: UUID!
    $color: String
    $positionX: Float
    $positionY: Float
  ) {
    addNode(
      newNode: {
        name: $name
        graphUuid: $graphUuid
        color: $color
        positionX: $positionX
        positionY: $positionY
      }
    )
  }
`;

export function useCreateNodeMutation() {
  return Urql.useMutation<CreateNodeMutation, CreateNodeMutationVariables>(
    CreateNodeDocument,
  );
}
export const UpdateNodeDocument = gql`
  mutation updateNode(
    $nodeUuid: UUID!
    $name: String
    $color: String
    $positionX: Float
    $positionY: Float
  ) {
    updateNode(
      nodeUpdate: {
        uuid: $nodeUuid
        name: $name
        color: $color
        positionX: $positionX
        positionY: $positionY
      }
    )
  }
`;

export function useUpdateNodeMutation() {
  return Urql.useMutation<UpdateNodeMutation, UpdateNodeMutationVariables>(
    UpdateNodeDocument,
  );
}
export const DeleteNodeDocument = gql`
  mutation deleteNode($nodeUuid: UUID!) {
    deleteNode(nodeUuid: $nodeUuid)
  }
`;

export function useDeleteNodeMutation() {
  return Urql.useMutation<DeleteNodeMutation, DeleteNodeMutationVariables>(
    DeleteNodeDocument,
  );
}
export const DeleteEdgeDocument = gql`
  mutation deleteEdge($edgeUuid: UUID!) {
    deleteEdge(edgeUuid: $edgeUuid)
  }
`;

export function useDeleteEdgeMutation() {
  return Urql.useMutation<DeleteEdgeMutation, DeleteEdgeMutationVariables>(
    DeleteEdgeDocument,
  );
}
export const CreateScriptCellsDocument = gql`
  mutation CreateScriptCells(
    $nodeUuid: UUID!
    $scriptCellInputs: [ScriptCellInputCreate!]!
  ) {
    createScriptCells(
      nodeUuid: $nodeUuid
      scriptCellInputs: $scriptCellInputs
    ) {
      uuid
    }
  }
`;

export function useCreateScriptCellsMutation() {
  return Urql.useMutation<
    CreateScriptCellsMutation,
    CreateScriptCellsMutationVariables
  >(CreateScriptCellsDocument);
}
export const UpdateScriptCellsDocument = gql`
  mutation UpdateScriptCells($scriptCellInputs: [ScriptCellInputUpdate!]!) {
    updateScriptCells(scriptCellInputs: $scriptCellInputs) {
      uuid
    }
  }
`;

export function useUpdateScriptCellsMutation() {
  return Urql.useMutation<
    UpdateScriptCellsMutation,
    UpdateScriptCellsMutationVariables
  >(UpdateScriptCellsDocument);
}
export const DeleteScriptCellDocument = gql`
  mutation deleteScriptCell($scriptCellUuid: UUID!) {
    deleteScriptCell(scriptCellUuid: $scriptCellUuid)
  }
`;

export function useDeleteScriptCellMutation() {
  return Urql.useMutation<
    DeleteScriptCellMutation,
    DeleteScriptCellMutationVariables
  >(DeleteScriptCellDocument);
}
export const GraphDocument = gql`
  subscription graph($uuid: UUID!) {
    graph(graphUuid: $uuid) {
      name
      slugName
      uuid
      edges {
        uuid
        inNodeDoor {
          ...NodeDoorBasic
        }
        outNodeDoor {
          ...NodeDoorBasic
        }
      }
      nodes {
        name
        uuid
        scriptCells {
          cellCode
          cellOrder
          cellType
          uuid
        }
        positionX
        positionY
        color
        isEntryNode
        inNodeDoors {
          ...NodeDoorBasic
        }
        outNodeDoors {
          ...NodeDoorBasic
        }
      }
    }
  }
  ${NodeDoorBasicFragmentDoc}
`;

export function useGraphSubscription<R = GraphSubscription>(
  options: Omit<
    Urql.UseSubscriptionArgs<never, GraphSubscriptionVariables>,
    "query"
  > = {},
  handler?: Urql.SubscriptionHandlerArg<GraphSubscription, R>,
) {
  return Urql.useSubscription<GraphSubscription, R, GraphSubscriptionVariables>(
    { query: GraphDocument, ...options },
    handler,
  );
}
export const NodeDocument = gql`
  subscription node($uuid: UUID!) {
    node(nodeUuid: $uuid) {
      inNodeDoors {
        ...NodeDoorDetail
      }
      outNodeDoors {
        ...NodeDoorDetail
      }
      color
      name
      positionX
      positionY
      isEntryNode
      scriptCells {
        cellCode
        cellOrder
        cellType
        uuid
        audioCell {
          playback
          uuid
          volume
          audioFile {
            uuid
            name
            autoGenerated
            description
            file {
              url
              name
            }
          }
        }
      }
      uuid
    }
  }
  ${NodeDoorDetailFragmentDoc}
`;

export function useNodeSubscription<R = NodeSubscription>(
  options: Omit<
    Urql.UseSubscriptionArgs<never, NodeSubscriptionVariables>,
    "query"
  > = {},
  handler?: Urql.SubscriptionHandlerArg<NodeSubscription, R>,
) {
  return Urql.useSubscription<NodeSubscription, R, NodeSubscriptionVariables>(
    { query: NodeDocument, ...options },
    handler,
  );
}
export const GetGraphDocument = gql`
  query GetGraph($graphUuid: ID!) {
    graph(pk: $graphUuid) {
      ...GraphMetaData
    }
  }
  ${GraphMetaDataFragmentDoc}
`;

export function useGetGraphQuery(
  options: Omit<Urql.UseQueryArgs<never, GetGraphQueryVariables>, "query"> = {},
) {
  return Urql.useQuery<GetGraphQuery>({ query: GetGraphDocument, ...options });
}
export const CreateGraphDocument = gql`
  mutation CreateGraph($graphInput: AddGraphInput!) {
    addGraph(graphInput: $graphInput) {
      name
      uuid
      nodes {
        name
        uuid
        isEntryNode
      }
    }
  }
`;

export function useCreateGraphMutation() {
  return Urql.useMutation<CreateGraphMutation, CreateGraphMutationVariables>(
    CreateGraphDocument,
  );
}
export const UpdateGraphDocument = gql`
  mutation UpdateGraph($graphUuid: UUID!, $graphUpdate: UpdateGraphInput!) {
    updateGraph(graphInput: $graphUpdate, graphUuid: $graphUuid) {
      uuid
    }
  }
`;

export function useUpdateGraphMutation() {
  return Urql.useMutation<UpdateGraphMutation, UpdateGraphMutationVariables>(
    UpdateGraphDocument,
  );
}
export const StreamDocument = gql`
  subscription stream($graphUuid: UUID!) {
    streamInfo(graphUuid: $graphUuid) {
      __typename
      ... on StreamInfo {
        __typename
        ...FullStreamInfo
        streamInstruction {
          createdDate
          instructionText
          modifiedDate
          state
          uuid
          returnValue
        }
      }
      ... on NoStreamAvailable {
        __typename
        error
      }
      ... on Dialog {
        __typename
        content {
          __typename
          ... on Text {
            __typename
            text
          }
          ... on Input {
            __typename
            label
            placeholder
            key
          }
          ... on Checkbox {
            __typename
            checked
            label
            key
            callbackActions
          }
        }
        buttons {
          __typename
          buttonType
          text
          key
          callbackActions
          value
        }
        title
      }
      ... on GraphDeadEnd {
        __typename
        error
      }
    }
  }
  ${FullStreamInfoFragmentDoc}
`;

export function useStreamSubscription<R = StreamSubscription>(
  options: Omit<
    Urql.UseSubscriptionArgs<never, StreamSubscriptionVariables>,
    "query"
  > = {},
  handler?: Urql.SubscriptionHandlerArg<StreamSubscription, R>,
) {
  return Urql.useSubscription<
    StreamSubscription,
    R,
    StreamSubscriptionVariables
  >({ query: StreamDocument, ...options }, handler);
}
export const StreamPointsDocument = gql`
  query streamPoints {
    streamPoints {
      createdDate
      host
      janusInPort
      janusInRoom
      janusOutPort
      janusOutRoom
      lastLive
      modifiedDate
      port
      useInput
      uuid
    }
  }
`;

export function useStreamPointsQuery(
  options: Omit<
    Urql.UseQueryArgs<never, StreamPointsQueryVariables>,
    "query"
  > = {},
) {
  return Urql.useQuery<StreamPointsQuery>({
    query: StreamPointsDocument,
    ...options,
  });
}
export const UploadAudioFileDocument = gql`
  mutation UploadAudioFile($addAudioFile: AddAudioFile!) {
    addAudioFile(newAudioFile: $addAudioFile) {
      ... on AudioFile {
        __typename
        ...AudioFileInfo
      }
      ... on InvalidAudioFile {
        __typename
        error
      }
    }
  }
  ${AudioFileInfoFragmentDoc}
`;

export function useUploadAudioFileMutation() {
  return Urql.useMutation<
    UploadAudioFileMutation,
    UploadAudioFileMutationVariables
  >(UploadAudioFileDocument);
}
export const SendStreamVariableDocument = gql`
  mutation SendStreamVariable($streamVariables: [StreamVariableInput!]!) {
    createUpdateStreamVariable(streamVariables: $streamVariables) {
      uuid
      value
    }
  }
`;

export function useSendStreamVariableMutation() {
  return Urql.useMutation<
    SendStreamVariableMutation,
    SendStreamVariableMutationVariables
  >(SendStreamVariableDocument);
}
export const AudioFilesDocument = gql`
  query AudioFiles(
    $autoGenerated: Boolean! = false
    $audioNameFilter: String! = ""
    $limit: Int = 50
    $offset: Int = 0
  ) {
    audioFiles(
      filters: {
        autoGenerated: $autoGenerated
        name: { iContains: $audioNameFilter }
      }
      pagination: { limit: $limit, offset: $offset }
    ) {
      ...AudioFileInfo
    }
  }
  ${AudioFileInfoFragmentDoc}
`;

export function useAudioFilesQuery(
  options: Omit<
    Urql.UseQueryArgs<never, AudioFilesQueryVariables>,
    "query"
  > = {},
) {
  return Urql.useQuery<AudioFilesQuery>({
    query: AudioFilesDocument,
    ...options,
  });
}
export const IsAuthenticatedDocument = gql`
  query IsAuthenticated {
    isAuthenticated {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`;

export function useIsAuthenticatedQuery(
  options: Omit<
    Urql.UseQueryArgs<never, IsAuthenticatedQueryVariables>,
    "query"
  > = {},
) {
  return Urql.useQuery<IsAuthenticatedQuery>({
    query: IsAuthenticatedDocument,
    ...options,
  });
}
export const LoginUserDocument = gql`
  mutation LoginUser($username: String!, $password: String!) {
    authLogin(password: $password, username: $username) {
      ... on LoginError {
        __typename
        errorMessage
      }
      ... on User {
        ...UserInfo
      }
    }
  }
  ${UserInfoFragmentDoc}
`;

export function useLoginUserMutation() {
  return Urql.useMutation<LoginUserMutation, LoginUserMutationVariables>(
    LoginUserDocument,
  );
}
export const LogoutDocument = gql`
  mutation Logout {
    authLogout
  }
`;

export function useLogoutMutation() {
  return Urql.useMutation<LogoutMutation, LogoutMutationVariables>(
    LogoutDocument,
  );
}
export const UpdateAudioFileDocument = gql`
  mutation UpdateAudioFile($uuid: UUID!, $updateAudioFile: UpdateAudioFile!) {
    updateAudioFile(updateAudioFile: $updateAudioFile, uuid: $uuid) {
      ...AudioFileInfo
    }
  }
  ${AudioFileInfoFragmentDoc}
`;

export function useUpdateAudioFileMutation() {
  return Urql.useMutation<
    UpdateAudioFileMutation,
    UpdateAudioFileMutationVariables
  >(UpdateAudioFileDocument);
}
export const StreamsDocument = gql`
  subscription Streams($numOfStreams: Int) {
    streams(limit: $numOfStreams) {
      ...StreamInfoFragment
    }
  }
  ${StreamInfoFragmentFragmentDoc}
`;

export function useStreamsSubscription<R = StreamsSubscription>(
  options: Omit<
    Urql.UseSubscriptionArgs<never, StreamsSubscriptionVariables>,
    "query"
  > = {},
  handler?: Urql.SubscriptionHandlerArg<StreamsSubscription, R>,
) {
  return Urql.useSubscription<
    StreamsSubscription,
    R,
    StreamsSubscriptionVariables
  >({ query: StreamsDocument, ...options }, handler);
}
export const StreamLogsDocument = gql`
  subscription StreamLogs($streamUuid: UUID, $streamPointUuid: UUID) {
    streamLogs(streamUuid: $streamUuid, streamPointUuid: $streamPointUuid) {
      createdDate
      level
      message
      name
      uuid
      stream {
        uuid
      }
      streamPoint {
        uuid
      }
    }
  }
`;

export function useStreamLogsSubscription<R = StreamLogsSubscription>(
  options: Omit<
    Urql.UseSubscriptionArgs<never, StreamLogsSubscriptionVariables>,
    "query"
  > = {},
  handler?: Urql.SubscriptionHandlerArg<StreamLogsSubscription, R>,
) {
  return Urql.useSubscription<
    StreamLogsSubscription,
    R,
    StreamLogsSubscriptionVariables
  >({ query: StreamLogsDocument, ...options }, handler);
}
export const CreateNodeDoorDocument = gql`
  mutation createNodeDoor(
    $nodeUuid: UUID!
    $name: String!
    $code: String! = ""
    $doorType: DoorType = OUTPUT
    $order: Int
  ) {
    createNodeDoor(
      nodeDoorInput: {
        name: $name
        code: $code
        doorType: $doorType
        order: $order
      }
      nodeUuid: $nodeUuid
    ) {
      uuid
    }
  }
`;

export function useCreateNodeDoorMutation() {
  return Urql.useMutation<
    CreateNodeDoorMutation,
    CreateNodeDoorMutationVariables
  >(CreateNodeDoorDocument);
}
export const DeleteNodeDoorDocument = gql`
  mutation deleteNodeDoor($nodeDoorUuid: UUID!) {
    deleteNodeDoor(nodeDoorUuid: $nodeDoorUuid)
  }
`;

export function useDeleteNodeDoorMutation() {
  return Urql.useMutation<
    DeleteNodeDoorMutation,
    DeleteNodeDoorMutationVariables
  >(DeleteNodeDoorDocument);
}
export const UpdateNodeDoorDocument = gql`
  mutation updateNodeDoor(
    $uuid: UUID!
    $name: String
    $code: String
    $order: Int
  ) {
    updateNodeDoor(
      nodeDoorInput: { name: $name, code: $code, order: $order, uuid: $uuid }
    ) {
      ... on NodeDoor {
        __typename
        uuid
      }
      ... on InvalidPythonCode {
        __typename
        errorCode
        errorMessage
        errorType
      }
    }
  }
`;

export function useUpdateNodeDoorMutation() {
  return Urql.useMutation<
    UpdateNodeDoorMutation,
    UpdateNodeDoorMutationVariables
  >(UpdateNodeDoorDocument);
}
