input AddAudioFile {
  file: Upload!
  description: String!
  fileName: String!
  name: String!
}

"""
A collection of :class:`~Node` and :class:`~Edge`.
This can be considered a score as well as a program as it
has an entry point as a :class:`~Node` and can jump to any
other :class:`~Node`, also allowing for recursive loops/cycles.

Each node can be considered a little program on its own which can consist
of multiple :class:`~ScriptCell` which can be coded in a variety of
languages which can control the frontend and the audio (by e.g. speaking
on the stream) or setting a background music.

The story graph is a core concept and can be edited with a native editor.
"""
input AddGraphInput {
  """Name of the graph"""
  name: String!

  """Will be used as a display name in the frontend"""
  displayName: String!

  """Will be used as a URL"""
  slugName: String!

  """
  Text about the graph which will be displayed at the start of a stream - only if this is set
  """
  startText: String

  """
  Text about the graph which can be accessed during a stream - only if this is set
  """
  aboutText: String

  """Text which will be displayed at the end of a stream"""
  endText: String

  """
  If the graph is not public it will not be listed in the frontend, yet it is still accessible via URL
  """
  publicVisible: Boolean

  """Manages the stream assignment for this graph"""
  streamAssignmentPolicy: String

  """
  Allows to switch to a different template in the frontend with different connection flows or UI
  """
  templateName: GraphDetailTemplate
}

"""AudioCell(uuid, playback, audio_file, volume)"""
type AudioCell {
  uuid: UUID!
  playback: PlaybackChoices!
  volume: Float!
  audioFile(pagination: OffsetPaginationInput): AudioFile!
}

"""AudioCell(uuid, playback, audio_file, volume)"""
input AudioCellInput {
  uuid: UUID = null
  playback: PlaybackChoices
  audioFile: AudioFileReference!
  volume: Float = 0.2
}

"""
Represents a local audio file on the server.
As SuperCollider and Django are running on the same server we
can pass these files to the SuperCollider instances as they
are mounted within each service.
"""
type AudioFile {
  uuid: UUID!
  file: DjangoFileType

  """Acts as an identifier for humans"""
  name: String!
  description: String!

  """
  Allows to separate automatic generated audio files speech to text and user uploads
  """
  autoGenerated: Boolean!
  createdDate: DateTime!
}

"""
Represents a local audio file on the server.
As SuperCollider and Django are running on the same server we
can pass these files to the SuperCollider instances as they
are mounted within each service.
"""
input AudioFileFilter {
  """Acts as an identifier for humans"""
  name: StrFilterLookup

  """
  Allows to separate automatic generated audio files speech to text and user uploads
  """
  autoGenerated: Boolean
  description: StrFilterLookup
}

"""
Represents a local audio file on the server.
As SuperCollider and Django are running on the same server we
can pass these files to the SuperCollider instances as they
are mounted within each service.
"""
input AudioFileReference {
  uuid: UUID
}

union AudioFileUploadResponse = AudioFile | InvalidAudioFile

"""A button which can also trigger a set of functionality."""
type Button {
  text: String!
  value: String!
  key: String!
  buttonType: ButtonType!
  callbackActions: [CallbackAction!]!
}

"""
Derived from ElementPlus framework, see
`https://element-plus.org/en-US/component/button.html`_.
"""
enum ButtonType {
  DEFAULT
  PRIMARY
  SUCCESS
  WARNING
  INFO
  DANGER
}

"""
Allows to add a pre-defined JavaScript callback to a button or a checkbox.

ACTIVATE_GPS_STREAMING          Activates streaming of GPS coordinates
                                as :class:`~stream.models.StreamVariable`.
                                If the GPS request succeeds the dialog will be closed,
                                if not it the user will be forwarded to an error page
                                which describes the setup procedure for the OS.
SEND_VARIABLES                  Send all variables of the form / dialog to
                                the server.
SEND_VARIABLE                   Sends a single :class:`~stream.models.StreamVariable`
                                with the key/value of the where the callback is
                                attached to.
"""
enum CallbackAction {
  ACTIVATE_GPS_STREAMING
  SEND_VARIABLES
  SEND_VARIABLE
}

"""Choice of foobar"""
enum CellType {
  MARKDOWN
  PYTHON
  SUPERCOLLIDER
  COMMENT
  AUDIO
}

"""
A classic ``<checkbox>`` whose state (``true``/``false``) will be
saved **as a string** under ``key`` in a :class:`~stream.models.StreamVariable`.
"""
type Checkbox {
  key: String!
  label: String!
  checked: Boolean!
  callbackActions: [CallbackAction!]!
}

union Content = Text | Input | Checkbox

"""Date with time (isoformat)"""
scalar DateTime

"""Triggers a popup on the frontend of the listener."""
type Dialog {
  title: String!
  content: [Content!]!
  buttons: [Button!]!
}

type DjangoFileType {
  name: String!
  path: String!
  size: Int!
  url: String!
}

"""
Connects two :class:`~Node` with each other.

.. todo::

    With a script we can also jump to any other node
    so it is not clear how to use this.
    Maybe take a look at visual programming languages
    such as MSP or Scratch how they handle this?
"""
type Edge {
  uuid: UUID!
  inNode: Node!
  outNode: Node!
}

input EdgeInput {
  nodeInUuid: UUID!
  nodeOutUuid: UUID!
}

"""
A collection of :class:`~Node` and :class:`~Edge`.
This can be considered a score as well as a program as it
has an entry point as a :class:`~Node` and can jump to any
other :class:`~Node`, also allowing for recursive loops/cycles.

Each node can be considered a little program on its own which can consist
of multiple :class:`~ScriptCell` which can be coded in a variety of
languages which can control the frontend and the audio (by e.g. speaking
on the stream) or setting a background music.

The story graph is a core concept and can be edited with a native editor.
"""
type Graph {
  uuid: UUID!

  """Name of the graph"""
  name: String!

  """Will be used as a display name in the frontend"""
  displayName: String!

  """Will be used as a URL"""
  slugName: String!

  """
  Allows to switch to a different template in the frontend with different connection flows or UI
  """
  templateName: GraphDetailTemplate!

  """
  Text about the graph which will be displayed at the start of a stream - only if this is set
  """
  startText: String!

  """
  Text about the graph which can be accessed during a stream - only if this is set
  """
  aboutText: String!

  """Text which will be displayed at the end of a stream"""
  endText: String!
  nodes: [Node!]!
  edges: [Edge!]!
}

"""An enumeration."""
enum GraphDetailTemplate {
  DEFAULT
}

"""
A collection of :class:`~Node` and :class:`~Edge`.
This can be considered a score as well as a program as it
has an entry point as a :class:`~Node` and can jump to any
other :class:`~Node`, also allowing for recursive loops/cycles.

Each node can be considered a little program on its own which can consist
of multiple :class:`~ScriptCell` which can be coded in a variety of
languages which can control the frontend and the audio (by e.g. speaking
on the stream) or setting a background music.

The story graph is a core concept and can be edited with a native editor.
"""
input GraphFilter {
  """Name of the graph"""
  name: StrFilterLookup

  """Will be used as a URL"""
  slugName: StrFilterLookup
}

"""
A classic ``<inptut>`` which will save its content
under the ``key`` as a :class:`~stream.models.StreamVariable`.
"""
type Input {
  key: String!
  label: String!
  placeholder: String!
}

input IntFilterLookup {
  exact: Int
  iExact: Int
  contains: Int
  iContains: Int
  inList: [Int!]
  gt: Int
  gte: Int
  lt: Int
  lte: Int
  startsWith: Int
  iStartsWith: Int
  endsWith: Int
  iEndsWith: Int
  range: [Int!]
  isNull: Boolean
  regex: String
  iRegex: String
}

"""Matches :class:`gencaster.stream.exceptions.InvalidAudioFile`."""
type InvalidAudioFile {
  error: String!
}

type LoginError {
  errorMessage: String
}

union LoginRequestResponse = LoginError | User

"""Mutations for Gencaster via GraphQL."""
type Mutation {
  authLogin(username: String!, password: String!): LoginRequestResponse!
  authLogout: Boolean!

  """Update metadata of an :class:`~stream.models.AudioFile` via a UUID"""
  updateAudioFile(uuid: UUID!, updateAudioFile: UpdateAudioFile!): AudioFile!

  """
  Creates a new :class:`~story_graph.models.Node` in a given
  ~class:`~story_graph.models.Graph`.
  Although it creates a new node with UUID we don't hand it back yet.
  """
  addNode(newNode: NodeCreate!): Void

  """
  Updates a given :class:`~story_graph.models.Node` which can be used
  for renaming or moving it across the canvas.
  """
  updateNode(nodeUpdate: NodeUpdate!): Void

  """
  Creates a :class:`~story_graph.models.Edge` for a given
  :class:`~story_graph.models.Graph`.
  It does not return the created edge.
  """
  addEdge(newEdge: EdgeInput!): Void

  """Deletes a given :class:`~story_graph.models.Edge`."""
  deleteEdge(edgeUuid: UUID!): Void

  """Deletes a given :class:`~story_graph.models.Node`."""
  deleteNode(nodeUuid: UUID!): Void

  """
  Creates or updates a given :class:`~story_graph.models.ScriptCell` to change its content.
  """
  createScriptCells(scriptCellInputs: [ScriptCellInputCreate!]!, nodeUuid: UUID!): [ScriptCell!]!
  updateScriptCells(scriptCellInputs: [ScriptCellInputUpdate!]!): [ScriptCell!]!

  """Deletes a given :class:`~story_graph.models.ScriptCell`."""
  deleteScriptCell(scriptCellUuid: UUID!): Void
  addGraph(graphInput: AddGraphInput!): Graph!
  addAudioFile(newAudioFile: AddAudioFile!): AudioFileUploadResponse!
  createUpdateStreamVariable(streamVariables: [StreamVariableInput!]!): [StreamVariable!]!
}

"""Matches :class:`gencaster.stream.exceptions.NoStreamAvailable`."""
type NoStreamAvailable {
  error: String!
}

"""A node."""
type Node {
  uuid: UUID!

  """Name of the node"""
  name: String!
  color: String!

  """x-Position in graph canvas"""
  positionX: Float!

  """y-Position in graph canvas"""
  positionY: Float!

  """
  Acts as a singular entrypoint for our graph.Only one such node can exist per graph.
  """
  isEntryNode: Boolean!
  inEdges: [Edge!]!
  outEdges: [Edge!]!
  scriptCells: [ScriptCell!]!
}

input NodeCreate {
  name: String!
  graphUuid: UUID!
  positionX: Float = null
  positionY: Float = null
  color: String = null
}

input NodeUpdate {
  uuid: UUID!
  name: String = null
  positionX: Float = null
  positionY: Float = null
  color: String = null
}

input OffsetPaginationInput {
  offset: Int! = 0
  limit: Int! = -1
}

"""An enumeration."""
enum PlaybackChoices {
  SYNC_PLAYBACK
  ASYNC_PLAYBACK
}

"""Queries for Gencaster."""
type Query {
  streamPoint(pk: ID!): StreamPoint!
  streamPoints(filters: StreamPointFilter): [StreamPoint!]!
  graphs(filters: GraphFilter): [Graph!]!
  graph(pk: ID!): Graph!
  nodes: [Node!]!
  node(pk: ID!): Node!
  audioFiles(filters: AudioFileFilter, pagination: OffsetPaginationInput): [AudioFile!]!
  audioFile(pk: ID!, pagination: OffsetPaginationInput): AudioFile!
  streamVariable(pk: ID!): StreamVariable!
  isAuthenticated: User
}

"""
Stores a script which can be executed
with our :class:`~story_graph.engine.Engine` on a
:class:`~stream.models.Stream`.
"""
type ScriptCell {
  uuid: UUID!
  node: Node!
  cellType: CellType!
  cellCode: String!
  cellOrder: Int!
  audioCell: AudioCell
}

"""
Stores a script which can be executed
with our :class:`~story_graph.engine.Engine` on a
:class:`~stream.models.Stream`.
"""
input ScriptCellInputCreate {
  cellType: CellType
  cellCode: String!
  cellOrder: Int = null
  audioCell: AudioCellInput
}

"""
Stores a script which can be executed
with our :class:`~story_graph.engine.Engine` on a
:class:`~stream.models.Stream`.
"""
input ScriptCellInputUpdate {
  uuid: UUID = "<class 'uuid.UUID'>"
  cellType: CellType
  cellCode: String
  cellOrder: Int
  audioCell: AudioCellInput
}

input StrFilterLookup {
  exact: String
  iExact: String
  contains: String
  iContains: String
  inList: [String!]
  gt: String
  gte: String
  lt: String
  lte: String
  startsWith: String
  iStartsWith: String
  endsWith: String
  iEndsWith: String
  range: [String!]
  isNull: Boolean
  regex: String
  iRegex: String
}

"""
Assigns a :class:`~StreamPoint` to a user/client.
This allows us to see which streams are currently in use
and also by which user.
It also allows us to trace past streams.
"""
type Stream {
  uuid: UUID!
  createdDate: DateTime!
  modifiedDate: DateTime!

  """
  Used as a garbage collection. If multiple users share the same stream we need to know when we can release the stream which happens if listener counter is 0. It starts with a default of 0 because this allows us to count stateless.
  """
  numListeners: Int!
  streamPoint: StreamPoint!
}

type StreamInfo {
  stream: Stream!
  streamInstruction: StreamInstruction
}

union StreamInfoResponse = StreamInfo | Dialog | NoStreamAvailable

"""
Instruction for a :class:`StreamPoint`, most likely to be
created from a :class:`~story_graph.models.ScriptCell`.
"""
type StreamInstruction {
  uuid: UUID!
  createdDate: DateTime!
  modifiedDate: DateTime!
  instructionText: String!
  state: String!
  returnValue: String!
  frontendDisplay: Dialog!
}

"""
Stores metadata for each SuperCollider/Janus instance
and how we can interact with this instance.

Every SuperCollider instance that send a beacon to us
via the :ref:`OSC Server` will be a StreamPoint.
Consider ``last_live`` to filter out non-live from live
instances.
"""
type StreamPoint {
  uuid: UUID!
  createdDate: DateTime!
  modifiedDate: DateTime!
  host: String!
  port: Int!

  """Accepts to send audio input"""
  useInput: Boolean!

  """RTP port where Janus streams the audio its received from user"""
  janusInPort: Int

  """RTP port where SuperCollider/gstreamer streams its audio to Janus"""
  janusOutPort: Int

  """Last live signal from SuperCollider server"""
  lastLive: DateTime

  """Audiobridge room ID under which Janus can send audio to SuperCollider"""
  janusInRoom: Int

  """Streaming room ID under which Janus serves audio from SuperCollider"""
  janusOutRoom: Int
}

"""
Stores metadata for each SuperCollider/Janus instance
and how we can interact with this instance.

Every SuperCollider instance that send a beacon to us
via the :ref:`OSC Server` will be a StreamPoint.
Consider ``last_live`` to filter out non-live from live
instances.
"""
input StreamPointFilter {
  uuid: UUIDFilterLookup

  """RTP port where Janus streams the audio its received from user"""
  janusInPort: IntFilterLookup
}

"""
Allows to store variables in a stream session as a key/value pair.

.. warning::

    Due to database constraints all keys and values will be stored
    as a string, so parsing a float, int or boolean requires
    type conversion.
"""
type StreamVariable {
  uuid: UUID!
  key: String!
  value: String!
  stream: Stream!

  """Stream values to SC as control rate Ndef"""
  streamToSc: Boolean!
}

input StreamVariableInput {
  streamUuid: UUID!
  key: String!
  value: String!
  streamToSc: Boolean! = false
}

type Subscription {
  """
  Used within the editor to synchronize any updates of the graph such as movement
  of a :class:`~story_graph.models.Node`.
  """
  graph(graphUuid: UUID!): Graph!

  """
  Used within the editor to synchronize any updates on a node such as updates on a
  :class:`~story_graph.models.ScriptCell`.
  """
  node(nodeUuid: UUID!): Node!

  """
  Used within the frontend to attach a user to a stream.
  :class:`~story_graph.engine.Engine` contains the specifics of how the iteration over a
  graph is handled.

  Upon visit the ``num_of_listeners`` of the associated
  :class:~stream.models.Stream` will be incremented which indicates
  if a given stream is free or used.
  Upon connection stop this will be decremented again.
  """
  streamInfo(graphUuid: UUID!): StreamInfoResponse!
}

"""Displays plain text."""
type Text {
  text: String!
}

scalar UUID

input UUIDFilterLookup {
  exact: UUID
  iExact: UUID
  contains: UUID
  iContains: UUID
  inList: [UUID!]
  gt: UUID
  gte: UUID
  lt: UUID
  lte: UUID
  startsWith: UUID
  iStartsWith: UUID
  endsWith: UUID
  iEndsWith: UUID
  range: [UUID!]
  isNull: Boolean
  regex: String
  iRegex: String
}

input UpdateAudioFile {
  description: String
  name: String
}

scalar Upload

"""
Users within the Django authentication system are represented by this
model.

Username and password are required. Other fields are optional.
"""
type User {
  """Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."""
  username: String!

  """Designates whether the user can log into this admin site."""
  isStaff: Boolean!

  """
  Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
  """
  isActive: Boolean!
  firstName: String!
  lastName: String!
  email: String!
}

"""Represents NULL values"""
scalar Void
