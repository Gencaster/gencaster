input AddAudioFile {
  file: Upload!
  description: String!
  fileName: String!
}

input AddGraphInput {
  name: String!
}

type AudioFile {
  uuid: UUID!
  file: DjangoFileType!
  description: String!
}

union AudioFileUploadResponse = AudioFile | InvalidAudioFile

"""Choice of foobar"""
enum CellType {
  MARKDOWN
  PYTHON
  SUPERCOLLIDER
  COMMENT
}

"""Date with time (isoformat)"""
scalar DateTime

type DjangoFileType {
  name: String!
  path: String!
  size: Int!
  url: String!
}

type Edge {
  uuid: UUID!
  inNode: Node!
  outNode: Node!
}

input EdgeInput {
  nodeInUuid: UUID!
  nodeOutUuid: UUID!
}

type Graph {
  uuid: UUID!
  name: String!
  nodes: [Node!]!
  edges: [Edge!]!
}

input IntFilterLookup {
  exact: Int
  iExact: Int
  contains: Int
  iContains: Int
  inList: [Int!]
  gt: Int
  gte: Int
  lt: Int
  lte: Int
  startsWith: Int
  iStartsWith: Int
  endsWith: Int
  iEndsWith: Int
  range: [Int!]
  isNull: Boolean
  regex: String
  iRegex: String
}

"""Matches :class:`gencaster.stream.exceptions.InvalidAudioFile`."""
type InvalidAudioFile {
  error: String!
}

"""Mutations for GenCaster via GraphQL."""
type Mutation {
  """
  Creates a new :class:`~story_graph.models.Node` in a given
  ~class:`~story_graph.models.Graph`.
  Although it creates a new node with UUID we don't hand it back yet.
  """
  addNode(newNode: NodeCreate!): Void

  """
  Updates a given :class:`~story_graph.models.Node` which can be used
  for renaming or moving it across the canvas.
  """
  updateNode(nodeUpdate: NodeUpdate!): Void

  """
  Creates a :class:`~story_graph.models.Edge` for a given
  :class:`~story_graph.models.Graph`.
  It does not return the created edge.
  """
  addEdge(newEdge: EdgeInput!): Void

  """Deletes a given :class:`~story_graph.models.Edge`."""
  deleteEdge(edgeUuid: UUID!): Void

  """Deletes a given :class:`~story_graph.models.Node`."""
  deleteNode(nodeUuid: UUID!): Void

  """
  Creates a new :class:`~story_graph.models.ScriptCell` for a given
  :class:`~story_graph.models.Edge` and returns this cell.
  """
  addScriptCell(nodeUuid: UUID!, newScriptCell: NewScriptCellInput!): ScriptCell!

  """
  Updates a given :class:`~story_graph.models.ScriptCell` to change its content.
  """
  updateScriptCells(newCells: [ScriptCellInput!]!): Void

  """Deletes a given :class:`~story_graph.models.ScriptCell`."""
  deleteScriptCell(scriptCellUuid: UUID!): Void
  addGraph(graphInput: AddGraphInput!): Graph!
  addAudioFile(newAudioFile: AddAudioFile!): AudioFileUploadResponse!
}

input NewScriptCellInput {
  cellType: CellType
  cellCode: String!
  cellOrder: Int
}

"""Matches :class:`gencaster.stream.exceptions.NoStreamAvailable`."""
type NoStreamAvailable {
  error: String!
}

type Node {
  uuid: UUID!
  name: String!
  color: String!
  positionX: Float!
  positionY: Float!
  isEntryNode: Boolean!
  inEdges: [Edge!]!
  outEdges: [Edge!]!
  scriptCells: [ScriptCell!]!
}

input NodeCreate {
  name: String!
  graphUuid: UUID!
  positionX: Float = null
  positionY: Float = null
  color: String = null
}

input NodeUpdate {
  uuid: UUID!
  name: String = null
  positionX: Float = null
  positionY: Float = null
  color: String = null
}

"""Queries for GenCaster."""
type Query {
  streamPoint(pk: ID!): StreamPoint!
  streamPoints(filters: StreamPointFilter): [StreamPoint!]!
  graphs: [Graph!]!
  graph(pk: ID!): Graph!
  nodes: [Node!]!
  node(pk: ID!): Node!
  audioFiles: [AudioFile!]!
  audioFile(pk: ID!): AudioFile!
}

type ScriptCell {
  uuid: UUID!
  node: Node!
  cellType: CellType!
  cellCode: String!
  cellOrder: Int!
}

input ScriptCellInput {
  uuid: UUID
  cellType: CellType
  cellCode: String!
  cellOrder: Int
}

type Stream {
  uuid: UUID!
  createdDate: DateTime!
  modifiedDate: DateTime!
  active: Boolean!
  streamPoint: StreamPoint!
}

type StreamInfo {
  stream: Stream!
  streamInstruction: StreamInstruction
}

union StreamInfoResponse = StreamInfo | NoStreamAvailable

type StreamInstruction {
  uuid: UUID!
  createdDate: DateTime!
  modifiedDate: DateTime!
  instructionText: String!
  state: String!
  returnValue: String!
}

type StreamPoint {
  uuid: UUID!
  createdDate: DateTime!
  modifiedDate: DateTime!
  host: String!
  port: Int!
  useInput: Boolean!
  janusInPort: Int
  janusOutPort: Int
  lastLive: DateTime
  janusInRoom: Int
  janusOutRoom: Int
}

input StreamPointFilter {
  uuid: UUIDFilterLookup
  janusInPort: IntFilterLookup
}

type Subscription {
  count(target: Int! = 100): Int!
  graph(graphUuid: UUID!): Graph!
  node(nodeUuid: UUID!): Node!
  streamInfo(graphUuid: UUID!): StreamInfoResponse!
}

scalar UUID

input UUIDFilterLookup {
  exact: UUID
  iExact: UUID
  contains: UUID
  iContains: UUID
  inList: [UUID!]
  gt: UUID
  gte: UUID
  lt: UUID
  lte: UUID
  startsWith: UUID
  iStartsWith: UUID
  endsWith: UUID
  iEndsWith: UUID
  range: [UUID!]
  isNull: Boolean
  regex: String
  iRegex: String
}

scalar Upload

"""Represents NULL values"""
scalar Void
