input AddAudioFile {
  file: Upload!
  description: String!
  fileName: String!
  name: String!
}

"""
A collection of :class:`~Node` and :class:`~Edge`.
This can be considered a score as well as a program as it
has an entry point as a :class:`~Node` and can jump to any
other :class:`~Node`, also allowing for recursive loops/cycles.

Each node can be considered a little program on its own which can consist
of multiple :class:`~ScriptCell` which can be coded in a variety of
languages which can control the frontend and the audio (by e.g. speaking
on the stream) or setting a background music.

The story graph is a core concept and can be edited with a native editor.
"""
input AddGraphInput {
  """Name of the graph"""
  name: String!

  """Will be used as a display name in the frontend"""
  displayName: String!

  """Will be used as a URL"""
  slugName: String!

  """
  Text about the graph which will be displayed at the start of a stream - only if this is set
  """
  startText: String

  """
  Text about the graph which can be accessed during a stream - only if this is set
  """
  aboutText: String

  """Text which will be displayed at the end of a stream"""
  endText: String

  """
  If the graph is not public it will not be listed in the frontend, yet it is still accessible via URL
  """
  publicVisible: Boolean

  """Manages the stream assignment for this graph"""
  streamAssignmentPolicy: String

  """
  Allows to switch to a different template in the frontend with different connection flows or UI
  """
  templateName: GraphDetailTemplate
}

"""AudioCell(uuid, playback, audio_file, volume)"""
type AudioCell {
  uuid: UUID!
  playback: PlaybackChoices!
  volume: Float!
  audioFile(pagination: OffsetPaginationInput): AudioFile!
}

"""AudioCell(uuid, playback, audio_file, volume)"""
input AudioCellInput {
  uuid: UUID = null
  playback: PlaybackChoices
  audioFile: AudioFileReference!
  volume: Float = 0.2
}

"""
Represents a local audio file on the server.
As SuperCollider and Django are running on the same server we
can pass these files to the SuperCollider instances as they
are mounted within each service.
"""
type AudioFile {
  uuid: UUID!
  file: DjangoFileType

  """Acts as an identifier for humans"""
  name: String!
  description: String!

  """
  Allows to separate automatic generated audio files speech to text and user uploads
  """
  autoGenerated: Boolean!
  createdDate: DateTime!
}

"""
Represents a local audio file on the server.
As SuperCollider and Django are running on the same server we
can pass these files to the SuperCollider instances as they
are mounted within each service.
"""
input AudioFileFilter {
  """Acts as an identifier for humans"""
  name: StrFilterLookup

  """
  Allows to separate automatic generated audio files speech to text and user uploads
  """
  autoGenerated: Boolean
  description: StrFilterLookup
}

"""
Represents a local audio file on the server.
As SuperCollider and Django are running on the same server we
can pass these files to the SuperCollider instances as they
are mounted within each service.
"""
input AudioFileReference {
  uuid: UUID
}

union AudioFileUploadResponse = AudioFile | InvalidAudioFile

"""Choice of foobar"""
enum CellType {
  MARKDOWN
  PYTHON
  SUPERCOLLIDER
  COMMENT
  AUDIO
}

"""Date with time (isoformat)"""
scalar DateTime

type DjangoFileType {
  name: String!
  path: String!
  size: Int!
  url: String!
}

"""
Connects two :class:`~Node` with each other.

.. todo::

    With a script we can also jump to any other node
    so it is not clear how to use this.
    Maybe take a look at visual programming languages
    such as MSP or Scratch how they handle this?
"""
type Edge {
  uuid: UUID!
  inNode: Node!
  outNode: Node!
}

input EdgeInput {
  nodeInUuid: UUID!
  nodeOutUuid: UUID!
}

"""
A collection of :class:`~Node` and :class:`~Edge`.
This can be considered a score as well as a program as it
has an entry point as a :class:`~Node` and can jump to any
other :class:`~Node`, also allowing for recursive loops/cycles.

Each node can be considered a little program on its own which can consist
of multiple :class:`~ScriptCell` which can be coded in a variety of
languages which can control the frontend and the audio (by e.g. speaking
on the stream) or setting a background music.

The story graph is a core concept and can be edited with a native editor.
"""
type Graph {
  uuid: UUID!

  """Name of the graph"""
  name: String!

  """Will be used as a display name in the frontend"""
  displayName: String!

  """Will be used as a URL"""
  slugName: String!

  """
  Allows to switch to a different template in the frontend with different connection flows or UI
  """
  templateName: GraphDetailTemplate!

  """
  Text about the graph which will be displayed at the start of a stream - only if this is set
  """
  startText: String!

  """
  Text about the graph which can be accessed during a stream - only if this is set
  """
  aboutText: String!

  """Text which will be displayed at the end of a stream"""
  endText: String!
  nodes: [Node!]!
  edges: [Edge!]!
}

"""An enumeration."""
enum GraphDetailTemplate {
  DEFAULT
  DRIFTER
}

"""
A collection of :class:`~Node` and :class:`~Edge`.
This can be considered a score as well as a program as it
has an entry point as a :class:`~Node` and can jump to any
other :class:`~Node`, also allowing for recursive loops/cycles.

Each node can be considered a little program on its own which can consist
of multiple :class:`~ScriptCell` which can be coded in a variety of
languages which can control the frontend and the audio (by e.g. speaking
on the stream) or setting a background music.

The story graph is a core concept and can be edited with a native editor.
"""
input GraphFilter {
  """Name of the graph"""
  name: StrFilterLookup

  """Will be used as a URL"""
  slugName: StrFilterLookup
}

input IntFilterLookup {
  exact: Int
  iExact: Int
  contains: Int
  iContains: Int
  inList: [Int!]
  gt: Int
  gte: Int
  lt: Int
  lte: Int
  startsWith: Int
  iStartsWith: Int
  endsWith: Int
  iEndsWith: Int
  range: [Int!]
  isNull: Boolean
  regex: String
  iRegex: String
}

"""Matches :class:`gencaster.stream.exceptions.InvalidAudioFile`."""
type InvalidAudioFile {
  error: String!
}

"""Mutations for Gencaster via GraphQL."""
type Mutation {
  """
  Creates a new :class:`~story_graph.models.Node` in a given
  ~class:`~story_graph.models.Graph`.
  Although it creates a new node with UUID we don't hand it back yet.
  """
  addNode(newNode: NodeCreate!): Void

  """
  Updates a given :class:`~story_graph.models.Node` which can be used
  for renaming or moving it across the canvas.
  """
  updateNode(nodeUpdate: NodeUpdate!): Void

  """
  Creates a :class:`~story_graph.models.Edge` for a given
  :class:`~story_graph.models.Graph`.
  It does not return the created edge.
  """
  addEdge(newEdge: EdgeInput!): Void

  """Deletes a given :class:`~story_graph.models.Edge`."""
  deleteEdge(edgeUuid: UUID!): Void

  """Deletes a given :class:`~story_graph.models.Node`."""
  deleteNode(nodeUuid: UUID!): Void

  """
  Creates or updates a given :class:`~story_graph.models.ScriptCell` to change its content.
  """
  createUpdateScriptCells(scriptCellInputs: [ScriptCellInput!]!, nodeUuid: UUID!): [ScriptCell!]!

  """Deletes a given :class:`~story_graph.models.ScriptCell`."""
  deleteScriptCell(scriptCellUuid: UUID!): Void
  addGraph(graphInput: AddGraphInput!): Graph!
  addAudioFile(newAudioFile: AddAudioFile!): AudioFileUploadResponse!
  createUpdateStreamVariable(streamVariables: [StreamVariableInput!]!): [StreamVariable!]!
}

"""Matches :class:`gencaster.stream.exceptions.NoStreamAvailable`."""
type NoStreamAvailable {
  error: String!
}

"""A node."""
type Node {
  uuid: UUID!

  """Name of the node"""
  name: String!
  color: String!

  """x-Position in graph canvas"""
  positionX: Float!

  """y-Position in graph canvas"""
  positionY: Float!

  """
  Acts as a singular entrypoint for our graph.Only one such node can exist per graph.
  """
  isEntryNode: Boolean!
  inEdges: [Edge!]!
  outEdges: [Edge!]!
  scriptCells: [ScriptCell!]!
}

input NodeCreate {
  name: String!
  graphUuid: UUID!
  positionX: Float = null
  positionY: Float = null
  color: String = null
}

input NodeUpdate {
  uuid: UUID!
  name: String = null
  positionX: Float = null
  positionY: Float = null
  color: String = null
}

input OffsetPaginationInput {
  offset: Int! = 0
  limit: Int! = -1
}

"""An enumeration."""
enum PlaybackChoices {
  SYNC_PLAYBACK
  ASYNC_PLAYBACK
}

"""Queries for Gencaster."""
type Query {
  streamPoint(pk: ID!): StreamPoint!
  streamPoints(filters: StreamPointFilter): [StreamPoint!]!
  graphs(filters: GraphFilter): [Graph!]!
  graph(pk: ID!): Graph!
  nodes: [Node!]!
  node(pk: ID!): Node!
  audioFiles(filters: AudioFileFilter, pagination: OffsetPaginationInput): [AudioFile!]!
  audioFile(pk: ID!, pagination: OffsetPaginationInput): AudioFile!
  streamVariable(pk: ID!): StreamVariable!
  isAuthenticated: User!
}

"""
Stores a script which can be executed
with our :class:`~story_graph.engine.Engine` on a
:class:`~stream.models.Stream`.
"""
type ScriptCell {
  uuid: UUID!
  node: Node!
  cellType: CellType!
  cellCode: String!
  cellOrder: Int!
  audioCell: AudioCell
}

"""
Stores a script which can be executed
with our :class:`~story_graph.engine.Engine` on a
:class:`~stream.models.Stream`.
"""
input ScriptCellInput {
  uuid: UUID = null
  cellType: CellType
  cellCode: String!
  cellOrder: Int = null
  audioCell: AudioCellInput
}

input StrFilterLookup {
  exact: String
  iExact: String
  contains: String
  iContains: String
  inList: [String!]
  gt: String
  gte: String
  lt: String
  lte: String
  startsWith: String
  iStartsWith: String
  endsWith: String
  iEndsWith: String
  range: [String!]
  isNull: Boolean
  regex: String
  iRegex: String
}

"""
Assigns a :class:`~StreamPoint` to a user/client.
This allows us to see which streams are currently in use
and also by which user.
It also allows us to trace past streams.
"""
type Stream {
  uuid: UUID!
  createdDate: DateTime!
  modifiedDate: DateTime!

  """
  Used as a garbage collection. If multiple users share the same stream we need to know when we can release the stream which happens if listener counter is 0. It starts with a default of 0 because this allows us to count stateless.
  """
  numListeners: Int!
  streamPoint: StreamPoint!
}

type StreamInfo {
  stream: Stream!
  streamInstruction: StreamInstruction
}

union StreamInfoResponse = StreamInfo | NoStreamAvailable

"""
Instruction for a :class:`StreamPoint`, most likely to be
created from a :class:`~story_graph.models.ScriptCell`.
"""
type StreamInstruction {
  uuid: UUID!
  createdDate: DateTime!
  modifiedDate: DateTime!
  instructionText: String!
  state: String!
  returnValue: String!
}

"""
Stores metadata for each SuperCollider/Janus instance
and how we can interact with this instance.

Every SuperCollider instance that send a beacon to us
via the :ref:`OSC Server` will be a StreamPoint.
Consider ``last_live`` to filter out non-live from live
instances.
"""
type StreamPoint {
  uuid: UUID!
  createdDate: DateTime!
  modifiedDate: DateTime!
  host: String!
  port: Int!

  """Accepts to send audio input"""
  useInput: Boolean!

  """RTP port where Janus streams the audio its received from user"""
  janusInPort: Int

  """RTP port where SuperCollider/gstreamer streams its audio to Janus"""
  janusOutPort: Int

  """Last live signal from SuperCollider server"""
  lastLive: DateTime

  """Audiobridge room ID under which Janus can send audio to SuperCollider"""
  janusInRoom: Int

  """Streaming room ID under which Janus serves audio from SuperCollider"""
  janusOutRoom: Int
}

"""
Stores metadata for each SuperCollider/Janus instance
and how we can interact with this instance.

Every SuperCollider instance that send a beacon to us
via the :ref:`OSC Server` will be a StreamPoint.
Consider ``last_live`` to filter out non-live from live
instances.
"""
input StreamPointFilter {
  uuid: UUIDFilterLookup

  """RTP port where Janus streams the audio its received from user"""
  janusInPort: IntFilterLookup
}

"""
Allows to store variables in a stream session as a key/value pair.
Due to database constraints we will store any value a string.
"""
type StreamVariable {
  uuid: UUID!
  key: String!
  value: String!
  stream: Stream!

  """Stream values to SC as control rate Ndef"""
  streamToSc: Boolean!
}

input StreamVariableInput {
  streamUuid: UUID!
  key: String!
  value: String!
  streamToSc: Boolean! = false
}

type Subscription {
  count(target: Int! = 100): Int!
  graph(graphUuid: UUID!): Graph!
  node(nodeUuid: UUID!): Node!
  streamInfo(graphUuid: UUID!): StreamInfoResponse!
}

scalar UUID

input UUIDFilterLookup {
  exact: UUID
  iExact: UUID
  contains: UUID
  iContains: UUID
  inList: [UUID!]
  gt: UUID
  gte: UUID
  lt: UUID
  lte: UUID
  startsWith: UUID
  iStartsWith: UUID
  endsWith: UUID
  iEndsWith: UUID
  range: [UUID!]
  isNull: Boolean
  regex: String
  iRegex: String
}

scalar Upload

"""
Users within the Django authentication system are represented by this
model.

Username and password are required. Other fields are optional.
"""
type User {
  """Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."""
  username: String!

  """Designates whether the user can log into this admin site."""
  isStaff: Boolean!

  """
  Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
  """
  isActive: Boolean!
  firstName: String!
  lastName: String!
  email: String!
}

"""Represents NULL values"""
scalar Void
